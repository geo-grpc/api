// This file is generated by rust-protobuf 2.10.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `epl/protobuf/geometry.proto`

// NOTE: THE FOLLOWING LINE WAS HAND-WRITTEN, DO NOT OMIT
use serde::{Deserialize, Serialize};
use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryData {
    // message fields
    pub geometry_id: u64,
    pub feature_id: ::std::string::String,
    pub wkt: ::std::string::String,
    pub geojson: ::std::string::String,
    pub wkb: ::std::vec::Vec<u8>,
    pub esri_shape: ::std::vec::Vec<u8>,
    pub sr: ::protobuf::SingularPtrField<SpatialReferenceData>,
    pub envelope: ::protobuf::SingularPtrField<EnvelopeData>,
    pub simple: SimpleState,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryData {
    fn default() -> &'a GeometryData {
        <GeometryData as ::protobuf::Message>::default_instance()
    }
}

impl GeometryData {
    pub fn new() -> GeometryData {
        ::std::default::Default::default()
    }

    // uint64 geometry_id = 1;


    pub fn get_geometry_id(&self) -> u64 {
        self.geometry_id
    }
    pub fn clear_geometry_id(&mut self) {
        self.geometry_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_geometry_id(&mut self, v: u64) {
        self.geometry_id = v;
    }

    // string feature_id = 2;


    pub fn get_feature_id(&self) -> &str {
        &self.feature_id
    }
    pub fn clear_feature_id(&mut self) {
        self.feature_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_feature_id(&mut self, v: ::std::string::String) {
        self.feature_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feature_id(&mut self) -> &mut ::std::string::String {
        &mut self.feature_id
    }

    // Take field
    pub fn take_feature_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feature_id, ::std::string::String::new())
    }

    // string wkt = 3;


    pub fn get_wkt(&self) -> &str {
        &self.wkt
    }
    pub fn clear_wkt(&mut self) {
        self.wkt.clear();
    }

    // Param is passed by value, moved
    pub fn set_wkt(&mut self, v: ::std::string::String) {
        self.wkt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wkt(&mut self) -> &mut ::std::string::String {
        &mut self.wkt
    }

    // Take field
    pub fn take_wkt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wkt, ::std::string::String::new())
    }

    // string geojson = 4;


    pub fn get_geojson(&self) -> &str {
        &self.geojson
    }
    pub fn clear_geojson(&mut self) {
        self.geojson.clear();
    }

    // Param is passed by value, moved
    pub fn set_geojson(&mut self, v: ::std::string::String) {
        self.geojson = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geojson(&mut self) -> &mut ::std::string::String {
        &mut self.geojson
    }

    // Take field
    pub fn take_geojson(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.geojson, ::std::string::String::new())
    }

    // bytes wkb = 5;


    pub fn get_wkb(&self) -> &[u8] {
        &self.wkb
    }
    pub fn clear_wkb(&mut self) {
        self.wkb.clear();
    }

    // Param is passed by value, moved
    pub fn set_wkb(&mut self, v: ::std::vec::Vec<u8>) {
        self.wkb = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wkb(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wkb
    }

    // Take field
    pub fn take_wkb(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wkb, ::std::vec::Vec::new())
    }

    // bytes esri_shape = 6;


    pub fn get_esri_shape(&self) -> &[u8] {
        &self.esri_shape
    }
    pub fn clear_esri_shape(&mut self) {
        self.esri_shape.clear();
    }

    // Param is passed by value, moved
    pub fn set_esri_shape(&mut self, v: ::std::vec::Vec<u8>) {
        self.esri_shape = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esri_shape(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.esri_shape
    }

    // Take field
    pub fn take_esri_shape(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.esri_shape, ::std::vec::Vec::new())
    }

    // .epl.protobuf.SpatialReferenceData sr = 7;


    pub fn get_sr(&self) -> &SpatialReferenceData {
        self.sr.as_ref().unwrap_or_else(|| SpatialReferenceData::default_instance())
    }
    pub fn clear_sr(&mut self) {
        self.sr.clear();
    }

    pub fn has_sr(&self) -> bool {
        self.sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sr(&mut self, v: SpatialReferenceData) {
        self.sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sr(&mut self) -> &mut SpatialReferenceData {
        if self.sr.is_none() {
            self.sr.set_default();
        }
        self.sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_sr(&mut self) -> SpatialReferenceData {
        self.sr.take().unwrap_or_else(|| SpatialReferenceData::new())
    }

    // .epl.protobuf.EnvelopeData envelope = 13;


    pub fn get_envelope(&self) -> &EnvelopeData {
        self.envelope.as_ref().unwrap_or_else(|| EnvelopeData::default_instance())
    }
    pub fn clear_envelope(&mut self) {
        self.envelope.clear();
    }

    pub fn has_envelope(&self) -> bool {
        self.envelope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_envelope(&mut self, v: EnvelopeData) {
        self.envelope = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_envelope(&mut self) -> &mut EnvelopeData {
        if self.envelope.is_none() {
            self.envelope.set_default();
        }
        self.envelope.as_mut().unwrap()
    }

    // Take field
    pub fn take_envelope(&mut self) -> EnvelopeData {
        self.envelope.take().unwrap_or_else(|| EnvelopeData::new())
    }

    // .epl.protobuf.SimpleState simple = 14;


    pub fn get_simple(&self) -> SimpleState {
        self.simple
    }
    pub fn clear_simple(&mut self) {
        self.simple = SimpleState::SIMPLE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_simple(&mut self, v: SimpleState) {
        self.simple = v;
    }
}

impl ::protobuf::Message for GeometryData {
    fn is_initialized(&self) -> bool {
        for v in &self.sr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.envelope {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.geometry_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feature_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wkt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.geojson)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wkb)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.esri_shape)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sr)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.envelope)?;
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.simple, 14, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.geometry_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.geometry_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.feature_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.feature_id);
        }
        if !self.wkt.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.wkt);
        }
        if !self.geojson.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.geojson);
        }
        if !self.wkb.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.wkb);
        }
        if !self.esri_shape.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.esri_shape);
        }
        if let Some(ref v) = self.sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.envelope.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.simple != SimpleState::SIMPLE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(14, self.simple);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.geometry_id != 0 {
            os.write_uint64(1, self.geometry_id)?;
        }
        if !self.feature_id.is_empty() {
            os.write_string(2, &self.feature_id)?;
        }
        if !self.wkt.is_empty() {
            os.write_string(3, &self.wkt)?;
        }
        if !self.geojson.is_empty() {
            os.write_string(4, &self.geojson)?;
        }
        if !self.wkb.is_empty() {
            os.write_bytes(5, &self.wkb)?;
        }
        if !self.esri_shape.is_empty() {
            os.write_bytes(6, &self.esri_shape)?;
        }
        if let Some(ref v) = self.sr.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.envelope.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.simple != SimpleState::SIMPLE_UNKNOWN {
            os.write_enum(14, self.simple.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryData {
        GeometryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "geometry_id",
                    |m: &GeometryData| { &m.geometry_id },
                    |m: &mut GeometryData| { &mut m.geometry_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "feature_id",
                    |m: &GeometryData| { &m.feature_id },
                    |m: &mut GeometryData| { &mut m.feature_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wkt",
                    |m: &GeometryData| { &m.wkt },
                    |m: &mut GeometryData| { &mut m.wkt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "geojson",
                    |m: &GeometryData| { &m.geojson },
                    |m: &mut GeometryData| { &mut m.geojson },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "wkb",
                    |m: &GeometryData| { &m.wkb },
                    |m: &mut GeometryData| { &mut m.wkb },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "esri_shape",
                    |m: &GeometryData| { &m.esri_shape },
                    |m: &mut GeometryData| { &mut m.esri_shape },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData>>(
                    "sr",
                    |m: &GeometryData| { &m.sr },
                    |m: &mut GeometryData| { &mut m.sr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvelopeData>>(
                    "envelope",
                    |m: &GeometryData| { &m.envelope },
                    |m: &mut GeometryData| { &mut m.envelope },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SimpleState>>(
                    "simple",
                    |m: &GeometryData| { &m.simple },
                    |m: &mut GeometryData| { &mut m.simple },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryData>(
                    "GeometryData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryData {
        static mut instance: ::protobuf::lazy::Lazy<GeometryData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryData,
        };
        unsafe {
            instance.get(GeometryData::new)
        }
    }
}

impl ::protobuf::Clear for GeometryData {
    fn clear(&mut self) {
        self.geometry_id = 0;
        self.feature_id.clear();
        self.wkt.clear();
        self.geojson.clear();
        self.wkb.clear();
        self.esri_shape.clear();
        self.sr.clear();
        self.envelope.clear();
        self.simple = SimpleState::SIMPLE_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SpatialReferenceData {
    // message fields
    pub wkid: i32,
    pub proj4: ::std::string::String,
    pub custom: ::protobuf::SingularPtrField<SpatialReferenceData_Custom>,
    pub wkt: ::std::string::String,
    pub esri_wkid: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpatialReferenceData {
    fn default() -> &'a SpatialReferenceData {
        <SpatialReferenceData as ::protobuf::Message>::default_instance()
    }
}

impl SpatialReferenceData {
    pub fn new() -> SpatialReferenceData {
        ::std::default::Default::default()
    }

    // int32 wkid = 1;


    pub fn get_wkid(&self) -> i32 {
        self.wkid
    }
    pub fn clear_wkid(&mut self) {
        self.wkid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wkid(&mut self, v: i32) {
        self.wkid = v;
    }

    // string proj4 = 2;


    pub fn get_proj4(&self) -> &str {
        &self.proj4
    }
    pub fn clear_proj4(&mut self) {
        self.proj4.clear();
    }

    // Param is passed by value, moved
    pub fn set_proj4(&mut self, v: ::std::string::String) {
        self.proj4 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proj4(&mut self) -> &mut ::std::string::String {
        &mut self.proj4
    }

    // Take field
    pub fn take_proj4(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proj4, ::std::string::String::new())
    }

    // .epl.protobuf.SpatialReferenceData.Custom custom = 3;


    pub fn get_custom(&self) -> &SpatialReferenceData_Custom {
        self.custom.as_ref().unwrap_or_else(|| SpatialReferenceData_Custom::default_instance())
    }
    pub fn clear_custom(&mut self) {
        self.custom.clear();
    }

    pub fn has_custom(&self) -> bool {
        self.custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom(&mut self, v: SpatialReferenceData_Custom) {
        self.custom = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom(&mut self) -> &mut SpatialReferenceData_Custom {
        if self.custom.is_none() {
            self.custom.set_default();
        }
        self.custom.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom(&mut self) -> SpatialReferenceData_Custom {
        self.custom.take().unwrap_or_else(|| SpatialReferenceData_Custom::new())
    }

    // string wkt = 4;


    pub fn get_wkt(&self) -> &str {
        &self.wkt
    }
    pub fn clear_wkt(&mut self) {
        self.wkt.clear();
    }

    // Param is passed by value, moved
    pub fn set_wkt(&mut self, v: ::std::string::String) {
        self.wkt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wkt(&mut self) -> &mut ::std::string::String {
        &mut self.wkt
    }

    // Take field
    pub fn take_wkt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wkt, ::std::string::String::new())
    }

    // int32 esri_wkid = 5;


    pub fn get_esri_wkid(&self) -> i32 {
        self.esri_wkid
    }
    pub fn clear_esri_wkid(&mut self) {
        self.esri_wkid = 0;
    }

    // Param is passed by value, moved
    pub fn set_esri_wkid(&mut self, v: i32) {
        self.esri_wkid = v;
    }
}

impl ::protobuf::Message for SpatialReferenceData {
    fn is_initialized(&self) -> bool {
        for v in &self.custom {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wkid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proj4)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.custom)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wkt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.esri_wkid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wkid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.wkid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proj4.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.proj4);
        }
        if let Some(ref v) = self.custom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.wkt.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.wkt);
        }
        if self.esri_wkid != 0 {
            my_size += ::protobuf::rt::value_size(5, self.esri_wkid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.wkid != 0 {
            os.write_int32(1, self.wkid)?;
        }
        if !self.proj4.is_empty() {
            os.write_string(2, &self.proj4)?;
        }
        if let Some(ref v) = self.custom.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.wkt.is_empty() {
            os.write_string(4, &self.wkt)?;
        }
        if self.esri_wkid != 0 {
            os.write_int32(5, self.esri_wkid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpatialReferenceData {
        SpatialReferenceData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "wkid",
                    |m: &SpatialReferenceData| { &m.wkid },
                    |m: &mut SpatialReferenceData| { &mut m.wkid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "proj4",
                    |m: &SpatialReferenceData| { &m.proj4 },
                    |m: &mut SpatialReferenceData| { &mut m.proj4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData_Custom>>(
                    "custom",
                    |m: &SpatialReferenceData| { &m.custom },
                    |m: &mut SpatialReferenceData| { &mut m.custom },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wkt",
                    |m: &SpatialReferenceData| { &m.wkt },
                    |m: &mut SpatialReferenceData| { &mut m.wkt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "esri_wkid",
                    |m: &SpatialReferenceData| { &m.esri_wkid },
                    |m: &mut SpatialReferenceData| { &mut m.esri_wkid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpatialReferenceData>(
                    "SpatialReferenceData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpatialReferenceData {
        static mut instance: ::protobuf::lazy::Lazy<SpatialReferenceData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpatialReferenceData,
        };
        unsafe {
            instance.get(SpatialReferenceData::new)
        }
    }
}

impl ::protobuf::Clear for SpatialReferenceData {
    fn clear(&mut self) {
        self.wkid = 0;
        self.proj4.clear();
        self.custom.clear();
        self.wkt.clear();
        self.esri_wkid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpatialReferenceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatialReferenceData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SpatialReferenceData_Custom {
    // message fields
    pub lon_0: f64,
    pub lat_0: f64,
    pub cs_type: SpatialReferenceData_CSType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpatialReferenceData_Custom {
    fn default() -> &'a SpatialReferenceData_Custom {
        <SpatialReferenceData_Custom as ::protobuf::Message>::default_instance()
    }
}

impl SpatialReferenceData_Custom {
    pub fn new() -> SpatialReferenceData_Custom {
        ::std::default::Default::default()
    }

    // double lon_0 = 1;


    pub fn get_lon_0(&self) -> f64 {
        self.lon_0
    }
    pub fn clear_lon_0(&mut self) {
        self.lon_0 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lon_0(&mut self, v: f64) {
        self.lon_0 = v;
    }

    // double lat_0 = 2;


    pub fn get_lat_0(&self) -> f64 {
        self.lat_0
    }
    pub fn clear_lat_0(&mut self) {
        self.lat_0 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lat_0(&mut self, v: f64) {
        self.lat_0 = v;
    }

    // .epl.protobuf.SpatialReferenceData.CSType cs_type = 3;


    pub fn get_cs_type(&self) -> SpatialReferenceData_CSType {
        self.cs_type
    }
    pub fn clear_cs_type(&mut self) {
        self.cs_type = SpatialReferenceData_CSType::LAMBERT_AZI;
    }

    // Param is passed by value, moved
    pub fn set_cs_type(&mut self, v: SpatialReferenceData_CSType) {
        self.cs_type = v;
    }
}

impl ::protobuf::Message for SpatialReferenceData_Custom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lon_0 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lat_0 = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cs_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lon_0 != 0. {
            my_size += 9;
        }
        if self.lat_0 != 0. {
            my_size += 9;
        }
        if self.cs_type != SpatialReferenceData_CSType::LAMBERT_AZI {
            my_size += ::protobuf::rt::enum_size(3, self.cs_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.lon_0 != 0. {
            os.write_double(1, self.lon_0)?;
        }
        if self.lat_0 != 0. {
            os.write_double(2, self.lat_0)?;
        }
        if self.cs_type != SpatialReferenceData_CSType::LAMBERT_AZI {
            os.write_enum(3, self.cs_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpatialReferenceData_Custom {
        SpatialReferenceData_Custom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lon_0",
                    |m: &SpatialReferenceData_Custom| { &m.lon_0 },
                    |m: &mut SpatialReferenceData_Custom| { &mut m.lon_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lat_0",
                    |m: &SpatialReferenceData_Custom| { &m.lat_0 },
                    |m: &mut SpatialReferenceData_Custom| { &mut m.lat_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SpatialReferenceData_CSType>>(
                    "cs_type",
                    |m: &SpatialReferenceData_Custom| { &m.cs_type },
                    |m: &mut SpatialReferenceData_Custom| { &mut m.cs_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpatialReferenceData_Custom>(
                    "SpatialReferenceData_Custom",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpatialReferenceData_Custom {
        static mut instance: ::protobuf::lazy::Lazy<SpatialReferenceData_Custom> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpatialReferenceData_Custom,
        };
        unsafe {
            instance.get(SpatialReferenceData_Custom::new)
        }
    }
}

impl ::protobuf::Clear for SpatialReferenceData_Custom {
    fn clear(&mut self) {
        self.lon_0 = 0.;
        self.lat_0 = 0.;
        self.cs_type = SpatialReferenceData_CSType::LAMBERT_AZI;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpatialReferenceData_Custom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatialReferenceData_Custom {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SpatialReferenceData_CSType {
    LAMBERT_AZI = 0,
}

impl ::protobuf::ProtobufEnum for SpatialReferenceData_CSType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpatialReferenceData_CSType> {
        match value {
            0 => ::std::option::Option::Some(SpatialReferenceData_CSType::LAMBERT_AZI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SpatialReferenceData_CSType] = &[
            SpatialReferenceData_CSType::LAMBERT_AZI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SpatialReferenceData_CSType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SpatialReferenceData_CSType {
}

impl ::std::default::Default for SpatialReferenceData_CSType {
    fn default() -> Self {
        SpatialReferenceData_CSType::LAMBERT_AZI
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatialReferenceData_CSType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EnvelopeData {
    // message fields
    pub xmin: f64,
    pub ymin: f64,
    pub xmax: f64,
    pub ymax: f64,
    pub sr: ::protobuf::SingularPtrField<SpatialReferenceData>,
    pub zmin: f64,
    pub zmax: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnvelopeData {
    fn default() -> &'a EnvelopeData {
        <EnvelopeData as ::protobuf::Message>::default_instance()
    }
}

impl EnvelopeData {
    pub fn new() -> EnvelopeData {
        ::std::default::Default::default()
    }

    // double xmin = 1;


    pub fn get_xmin(&self) -> f64 {
        self.xmin
    }
    pub fn clear_xmin(&mut self) {
        self.xmin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_xmin(&mut self, v: f64) {
        self.xmin = v;
    }

    // double ymin = 2;


    pub fn get_ymin(&self) -> f64 {
        self.ymin
    }
    pub fn clear_ymin(&mut self) {
        self.ymin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ymin(&mut self, v: f64) {
        self.ymin = v;
    }

    // double xmax = 3;


    pub fn get_xmax(&self) -> f64 {
        self.xmax
    }
    pub fn clear_xmax(&mut self) {
        self.xmax = 0.;
    }

    // Param is passed by value, moved
    pub fn set_xmax(&mut self, v: f64) {
        self.xmax = v;
    }

    // double ymax = 4;


    pub fn get_ymax(&self) -> f64 {
        self.ymax
    }
    pub fn clear_ymax(&mut self) {
        self.ymax = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ymax(&mut self, v: f64) {
        self.ymax = v;
    }

    // .epl.protobuf.SpatialReferenceData sr = 5;


    pub fn get_sr(&self) -> &SpatialReferenceData {
        self.sr.as_ref().unwrap_or_else(|| SpatialReferenceData::default_instance())
    }
    pub fn clear_sr(&mut self) {
        self.sr.clear();
    }

    pub fn has_sr(&self) -> bool {
        self.sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sr(&mut self, v: SpatialReferenceData) {
        self.sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sr(&mut self) -> &mut SpatialReferenceData {
        if self.sr.is_none() {
            self.sr.set_default();
        }
        self.sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_sr(&mut self) -> SpatialReferenceData {
        self.sr.take().unwrap_or_else(|| SpatialReferenceData::new())
    }

    // double zmin = 6;


    pub fn get_zmin(&self) -> f64 {
        self.zmin
    }
    pub fn clear_zmin(&mut self) {
        self.zmin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_zmin(&mut self, v: f64) {
        self.zmin = v;
    }

    // double zmax = 7;


    pub fn get_zmax(&self) -> f64 {
        self.zmax
    }
    pub fn clear_zmax(&mut self) {
        self.zmax = 0.;
    }

    // Param is passed by value, moved
    pub fn set_zmax(&mut self, v: f64) {
        self.zmax = v;
    }
}

impl ::protobuf::Message for EnvelopeData {
    fn is_initialized(&self) -> bool {
        for v in &self.sr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.xmin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ymin = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.xmax = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ymax = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sr)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.zmin = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.zmax = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.xmin != 0. {
            my_size += 9;
        }
        if self.ymin != 0. {
            my_size += 9;
        }
        if self.xmax != 0. {
            my_size += 9;
        }
        if self.ymax != 0. {
            my_size += 9;
        }
        if let Some(ref v) = self.sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.zmin != 0. {
            my_size += 9;
        }
        if self.zmax != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.xmin != 0. {
            os.write_double(1, self.xmin)?;
        }
        if self.ymin != 0. {
            os.write_double(2, self.ymin)?;
        }
        if self.xmax != 0. {
            os.write_double(3, self.xmax)?;
        }
        if self.ymax != 0. {
            os.write_double(4, self.ymax)?;
        }
        if let Some(ref v) = self.sr.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.zmin != 0. {
            os.write_double(6, self.zmin)?;
        }
        if self.zmax != 0. {
            os.write_double(7, self.zmax)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnvelopeData {
        EnvelopeData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "xmin",
                    |m: &EnvelopeData| { &m.xmin },
                    |m: &mut EnvelopeData| { &mut m.xmin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ymin",
                    |m: &EnvelopeData| { &m.ymin },
                    |m: &mut EnvelopeData| { &mut m.ymin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "xmax",
                    |m: &EnvelopeData| { &m.xmax },
                    |m: &mut EnvelopeData| { &mut m.xmax },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ymax",
                    |m: &EnvelopeData| { &m.ymax },
                    |m: &mut EnvelopeData| { &mut m.ymax },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData>>(
                    "sr",
                    |m: &EnvelopeData| { &m.sr },
                    |m: &mut EnvelopeData| { &mut m.sr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "zmin",
                    |m: &EnvelopeData| { &m.zmin },
                    |m: &mut EnvelopeData| { &mut m.zmin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "zmax",
                    |m: &EnvelopeData| { &m.zmax },
                    |m: &mut EnvelopeData| { &mut m.zmax },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnvelopeData>(
                    "EnvelopeData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnvelopeData {
        static mut instance: ::protobuf::lazy::Lazy<EnvelopeData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnvelopeData,
        };
        unsafe {
            instance.get(EnvelopeData::new)
        }
    }
}

impl ::protobuf::Clear for EnvelopeData {
    fn clear(&mut self) {
        self.xmin = 0.;
        self.ymin = 0.;
        self.xmax = 0.;
        self.ymax = 0.;
        self.sr.clear();
        self.zmin = 0.;
        self.zmax = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvelopeData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvelopeData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest {
    // message fields
    pub geometry: ::protobuf::SingularPtrField<GeometryData>,
    pub left_geometry: ::protobuf::SingularPtrField<GeometryData>,
    pub geometry_request: ::protobuf::SingularPtrField<GeometryRequest>,
    pub left_geometry_request: ::protobuf::SingularPtrField<GeometryRequest>,
    pub right_geometry: ::protobuf::SingularPtrField<GeometryData>,
    pub right_geometry_request: ::protobuf::SingularPtrField<GeometryRequest>,
    pub operator: OperatorType,
    pub result_encoding: Encoding,
    pub operation_sr: ::protobuf::SingularPtrField<SpatialReferenceData>,
    pub result_sr: ::protobuf::SingularPtrField<SpatialReferenceData>,
    pub buffer_params: ::protobuf::SingularPtrField<GeometryRequest_BufferParams>,
    pub convex_params: ::protobuf::SingularPtrField<GeometryRequest_ConvexParams>,
    pub relate_params: ::protobuf::SingularPtrField<GeometryRequest_RelateParams>,
    pub random_points_params: ::protobuf::SingularPtrField<GeometryRequest_RandomPointsParams>,
    pub generalize_params: ::protobuf::SingularPtrField<GeometryRequest_GeneralizeParams>,
    pub intersection_params: ::protobuf::SingularPtrField<GeometryRequest_IntersectionParams>,
    pub offset_params: ::protobuf::SingularPtrField<GeometryRequest_OffsetParams>,
    pub cut_params: ::protobuf::SingularPtrField<GeometryRequest_CutParams>,
    pub clip_params: ::protobuf::SingularPtrField<GeometryRequest_ClipParams>,
    pub densify_params: ::protobuf::SingularPtrField<GeometryRequest_DensifyParams>,
    pub simplify_params: ::protobuf::SingularPtrField<GeometryRequest_SimplifyParams>,
    pub generalize_by_area_params: ::protobuf::SingularPtrField<GeometryRequest_GeneralizeByAreaParams>,
    pub affine_transform_params: ::protobuf::SingularPtrField<GeometryRequest_AffineTransformParams>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest {
    fn default() -> &'a GeometryRequest {
        <GeometryRequest as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest {
    pub fn new() -> GeometryRequest {
        ::std::default::Default::default()
    }

    // .epl.protobuf.GeometryData geometry = 1;


    pub fn get_geometry(&self) -> &GeometryData {
        self.geometry.as_ref().unwrap_or_else(|| GeometryData::default_instance())
    }
    pub fn clear_geometry(&mut self) {
        self.geometry.clear();
    }

    pub fn has_geometry(&self) -> bool {
        self.geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: GeometryData) {
        self.geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry(&mut self) -> &mut GeometryData {
        if self.geometry.is_none() {
            self.geometry.set_default();
        }
        self.geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry(&mut self) -> GeometryData {
        self.geometry.take().unwrap_or_else(|| GeometryData::new())
    }

    // .epl.protobuf.GeometryData left_geometry = 2;


    pub fn get_left_geometry(&self) -> &GeometryData {
        self.left_geometry.as_ref().unwrap_or_else(|| GeometryData::default_instance())
    }
    pub fn clear_left_geometry(&mut self) {
        self.left_geometry.clear();
    }

    pub fn has_left_geometry(&self) -> bool {
        self.left_geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_geometry(&mut self, v: GeometryData) {
        self.left_geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left_geometry(&mut self) -> &mut GeometryData {
        if self.left_geometry.is_none() {
            self.left_geometry.set_default();
        }
        self.left_geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_left_geometry(&mut self) -> GeometryData {
        self.left_geometry.take().unwrap_or_else(|| GeometryData::new())
    }

    // .epl.protobuf.GeometryRequest geometry_request = 3;


    pub fn get_geometry_request(&self) -> &GeometryRequest {
        self.geometry_request.as_ref().unwrap_or_else(|| GeometryRequest::default_instance())
    }
    pub fn clear_geometry_request(&mut self) {
        self.geometry_request.clear();
    }

    pub fn has_geometry_request(&self) -> bool {
        self.geometry_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry_request(&mut self, v: GeometryRequest) {
        self.geometry_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry_request(&mut self) -> &mut GeometryRequest {
        if self.geometry_request.is_none() {
            self.geometry_request.set_default();
        }
        self.geometry_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry_request(&mut self) -> GeometryRequest {
        self.geometry_request.take().unwrap_or_else(|| GeometryRequest::new())
    }

    // .epl.protobuf.GeometryRequest left_geometry_request = 4;


    pub fn get_left_geometry_request(&self) -> &GeometryRequest {
        self.left_geometry_request.as_ref().unwrap_or_else(|| GeometryRequest::default_instance())
    }
    pub fn clear_left_geometry_request(&mut self) {
        self.left_geometry_request.clear();
    }

    pub fn has_left_geometry_request(&self) -> bool {
        self.left_geometry_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_geometry_request(&mut self, v: GeometryRequest) {
        self.left_geometry_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left_geometry_request(&mut self) -> &mut GeometryRequest {
        if self.left_geometry_request.is_none() {
            self.left_geometry_request.set_default();
        }
        self.left_geometry_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_left_geometry_request(&mut self) -> GeometryRequest {
        self.left_geometry_request.take().unwrap_or_else(|| GeometryRequest::new())
    }

    // .epl.protobuf.GeometryData right_geometry = 5;


    pub fn get_right_geometry(&self) -> &GeometryData {
        self.right_geometry.as_ref().unwrap_or_else(|| GeometryData::default_instance())
    }
    pub fn clear_right_geometry(&mut self) {
        self.right_geometry.clear();
    }

    pub fn has_right_geometry(&self) -> bool {
        self.right_geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_geometry(&mut self, v: GeometryData) {
        self.right_geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right_geometry(&mut self) -> &mut GeometryData {
        if self.right_geometry.is_none() {
            self.right_geometry.set_default();
        }
        self.right_geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_right_geometry(&mut self) -> GeometryData {
        self.right_geometry.take().unwrap_or_else(|| GeometryData::new())
    }

    // .epl.protobuf.GeometryRequest right_geometry_request = 6;


    pub fn get_right_geometry_request(&self) -> &GeometryRequest {
        self.right_geometry_request.as_ref().unwrap_or_else(|| GeometryRequest::default_instance())
    }
    pub fn clear_right_geometry_request(&mut self) {
        self.right_geometry_request.clear();
    }

    pub fn has_right_geometry_request(&self) -> bool {
        self.right_geometry_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_geometry_request(&mut self, v: GeometryRequest) {
        self.right_geometry_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right_geometry_request(&mut self) -> &mut GeometryRequest {
        if self.right_geometry_request.is_none() {
            self.right_geometry_request.set_default();
        }
        self.right_geometry_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_right_geometry_request(&mut self) -> GeometryRequest {
        self.right_geometry_request.take().unwrap_or_else(|| GeometryRequest::new())
    }

    // .epl.protobuf.OperatorType operator = 7;


    pub fn get_operator(&self) -> OperatorType {
        self.operator
    }
    pub fn clear_operator(&mut self) {
        self.operator = OperatorType::UNKNOWN_OPERATOR;
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: OperatorType) {
        self.operator = v;
    }

    // .epl.protobuf.Encoding result_encoding = 8;


    pub fn get_result_encoding(&self) -> Encoding {
        self.result_encoding
    }
    pub fn clear_result_encoding(&mut self) {
        self.result_encoding = Encoding::UNKNOWN_ENCODING;
    }

    // Param is passed by value, moved
    pub fn set_result_encoding(&mut self, v: Encoding) {
        self.result_encoding = v;
    }

    // .epl.protobuf.SpatialReferenceData operation_sr = 9;


    pub fn get_operation_sr(&self) -> &SpatialReferenceData {
        self.operation_sr.as_ref().unwrap_or_else(|| SpatialReferenceData::default_instance())
    }
    pub fn clear_operation_sr(&mut self) {
        self.operation_sr.clear();
    }

    pub fn has_operation_sr(&self) -> bool {
        self.operation_sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_sr(&mut self, v: SpatialReferenceData) {
        self.operation_sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_sr(&mut self) -> &mut SpatialReferenceData {
        if self.operation_sr.is_none() {
            self.operation_sr.set_default();
        }
        self.operation_sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation_sr(&mut self) -> SpatialReferenceData {
        self.operation_sr.take().unwrap_or_else(|| SpatialReferenceData::new())
    }

    // .epl.protobuf.SpatialReferenceData result_sr = 10;


    pub fn get_result_sr(&self) -> &SpatialReferenceData {
        self.result_sr.as_ref().unwrap_or_else(|| SpatialReferenceData::default_instance())
    }
    pub fn clear_result_sr(&mut self) {
        self.result_sr.clear();
    }

    pub fn has_result_sr(&self) -> bool {
        self.result_sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_sr(&mut self, v: SpatialReferenceData) {
        self.result_sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_sr(&mut self) -> &mut SpatialReferenceData {
        if self.result_sr.is_none() {
            self.result_sr.set_default();
        }
        self.result_sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_sr(&mut self) -> SpatialReferenceData {
        self.result_sr.take().unwrap_or_else(|| SpatialReferenceData::new())
    }

    // .epl.protobuf.GeometryRequest.BufferParams buffer_params = 11;


    pub fn get_buffer_params(&self) -> &GeometryRequest_BufferParams {
        self.buffer_params.as_ref().unwrap_or_else(|| GeometryRequest_BufferParams::default_instance())
    }
    pub fn clear_buffer_params(&mut self) {
        self.buffer_params.clear();
    }

    pub fn has_buffer_params(&self) -> bool {
        self.buffer_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer_params(&mut self, v: GeometryRequest_BufferParams) {
        self.buffer_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer_params(&mut self) -> &mut GeometryRequest_BufferParams {
        if self.buffer_params.is_none() {
            self.buffer_params.set_default();
        }
        self.buffer_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer_params(&mut self) -> GeometryRequest_BufferParams {
        self.buffer_params.take().unwrap_or_else(|| GeometryRequest_BufferParams::new())
    }

    // .epl.protobuf.GeometryRequest.ConvexParams convex_params = 12;


    pub fn get_convex_params(&self) -> &GeometryRequest_ConvexParams {
        self.convex_params.as_ref().unwrap_or_else(|| GeometryRequest_ConvexParams::default_instance())
    }
    pub fn clear_convex_params(&mut self) {
        self.convex_params.clear();
    }

    pub fn has_convex_params(&self) -> bool {
        self.convex_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convex_params(&mut self, v: GeometryRequest_ConvexParams) {
        self.convex_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convex_params(&mut self) -> &mut GeometryRequest_ConvexParams {
        if self.convex_params.is_none() {
            self.convex_params.set_default();
        }
        self.convex_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_convex_params(&mut self) -> GeometryRequest_ConvexParams {
        self.convex_params.take().unwrap_or_else(|| GeometryRequest_ConvexParams::new())
    }

    // .epl.protobuf.GeometryRequest.RelateParams relate_params = 13;


    pub fn get_relate_params(&self) -> &GeometryRequest_RelateParams {
        self.relate_params.as_ref().unwrap_or_else(|| GeometryRequest_RelateParams::default_instance())
    }
    pub fn clear_relate_params(&mut self) {
        self.relate_params.clear();
    }

    pub fn has_relate_params(&self) -> bool {
        self.relate_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relate_params(&mut self, v: GeometryRequest_RelateParams) {
        self.relate_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relate_params(&mut self) -> &mut GeometryRequest_RelateParams {
        if self.relate_params.is_none() {
            self.relate_params.set_default();
        }
        self.relate_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_relate_params(&mut self) -> GeometryRequest_RelateParams {
        self.relate_params.take().unwrap_or_else(|| GeometryRequest_RelateParams::new())
    }

    // .epl.protobuf.GeometryRequest.RandomPointsParams random_points_params = 14;


    pub fn get_random_points_params(&self) -> &GeometryRequest_RandomPointsParams {
        self.random_points_params.as_ref().unwrap_or_else(|| GeometryRequest_RandomPointsParams::default_instance())
    }
    pub fn clear_random_points_params(&mut self) {
        self.random_points_params.clear();
    }

    pub fn has_random_points_params(&self) -> bool {
        self.random_points_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_points_params(&mut self, v: GeometryRequest_RandomPointsParams) {
        self.random_points_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random_points_params(&mut self) -> &mut GeometryRequest_RandomPointsParams {
        if self.random_points_params.is_none() {
            self.random_points_params.set_default();
        }
        self.random_points_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_random_points_params(&mut self) -> GeometryRequest_RandomPointsParams {
        self.random_points_params.take().unwrap_or_else(|| GeometryRequest_RandomPointsParams::new())
    }

    // .epl.protobuf.GeometryRequest.GeneralizeParams generalize_params = 15;


    pub fn get_generalize_params(&self) -> &GeometryRequest_GeneralizeParams {
        self.generalize_params.as_ref().unwrap_or_else(|| GeometryRequest_GeneralizeParams::default_instance())
    }
    pub fn clear_generalize_params(&mut self) {
        self.generalize_params.clear();
    }

    pub fn has_generalize_params(&self) -> bool {
        self.generalize_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generalize_params(&mut self, v: GeometryRequest_GeneralizeParams) {
        self.generalize_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generalize_params(&mut self) -> &mut GeometryRequest_GeneralizeParams {
        if self.generalize_params.is_none() {
            self.generalize_params.set_default();
        }
        self.generalize_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_generalize_params(&mut self) -> GeometryRequest_GeneralizeParams {
        self.generalize_params.take().unwrap_or_else(|| GeometryRequest_GeneralizeParams::new())
    }

    // .epl.protobuf.GeometryRequest.IntersectionParams intersection_params = 16;


    pub fn get_intersection_params(&self) -> &GeometryRequest_IntersectionParams {
        self.intersection_params.as_ref().unwrap_or_else(|| GeometryRequest_IntersectionParams::default_instance())
    }
    pub fn clear_intersection_params(&mut self) {
        self.intersection_params.clear();
    }

    pub fn has_intersection_params(&self) -> bool {
        self.intersection_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intersection_params(&mut self, v: GeometryRequest_IntersectionParams) {
        self.intersection_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intersection_params(&mut self) -> &mut GeometryRequest_IntersectionParams {
        if self.intersection_params.is_none() {
            self.intersection_params.set_default();
        }
        self.intersection_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_intersection_params(&mut self) -> GeometryRequest_IntersectionParams {
        self.intersection_params.take().unwrap_or_else(|| GeometryRequest_IntersectionParams::new())
    }

    // .epl.protobuf.GeometryRequest.OffsetParams offset_params = 17;


    pub fn get_offset_params(&self) -> &GeometryRequest_OffsetParams {
        self.offset_params.as_ref().unwrap_or_else(|| GeometryRequest_OffsetParams::default_instance())
    }
    pub fn clear_offset_params(&mut self) {
        self.offset_params.clear();
    }

    pub fn has_offset_params(&self) -> bool {
        self.offset_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_params(&mut self, v: GeometryRequest_OffsetParams) {
        self.offset_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offset_params(&mut self) -> &mut GeometryRequest_OffsetParams {
        if self.offset_params.is_none() {
            self.offset_params.set_default();
        }
        self.offset_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_offset_params(&mut self) -> GeometryRequest_OffsetParams {
        self.offset_params.take().unwrap_or_else(|| GeometryRequest_OffsetParams::new())
    }

    // .epl.protobuf.GeometryRequest.CutParams cut_params = 18;


    pub fn get_cut_params(&self) -> &GeometryRequest_CutParams {
        self.cut_params.as_ref().unwrap_or_else(|| GeometryRequest_CutParams::default_instance())
    }
    pub fn clear_cut_params(&mut self) {
        self.cut_params.clear();
    }

    pub fn has_cut_params(&self) -> bool {
        self.cut_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cut_params(&mut self, v: GeometryRequest_CutParams) {
        self.cut_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cut_params(&mut self) -> &mut GeometryRequest_CutParams {
        if self.cut_params.is_none() {
            self.cut_params.set_default();
        }
        self.cut_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_cut_params(&mut self) -> GeometryRequest_CutParams {
        self.cut_params.take().unwrap_or_else(|| GeometryRequest_CutParams::new())
    }

    // .epl.protobuf.GeometryRequest.ClipParams clip_params = 19;


    pub fn get_clip_params(&self) -> &GeometryRequest_ClipParams {
        self.clip_params.as_ref().unwrap_or_else(|| GeometryRequest_ClipParams::default_instance())
    }
    pub fn clear_clip_params(&mut self) {
        self.clip_params.clear();
    }

    pub fn has_clip_params(&self) -> bool {
        self.clip_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clip_params(&mut self, v: GeometryRequest_ClipParams) {
        self.clip_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clip_params(&mut self) -> &mut GeometryRequest_ClipParams {
        if self.clip_params.is_none() {
            self.clip_params.set_default();
        }
        self.clip_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_clip_params(&mut self) -> GeometryRequest_ClipParams {
        self.clip_params.take().unwrap_or_else(|| GeometryRequest_ClipParams::new())
    }

    // .epl.protobuf.GeometryRequest.DensifyParams densify_params = 20;


    pub fn get_densify_params(&self) -> &GeometryRequest_DensifyParams {
        self.densify_params.as_ref().unwrap_or_else(|| GeometryRequest_DensifyParams::default_instance())
    }
    pub fn clear_densify_params(&mut self) {
        self.densify_params.clear();
    }

    pub fn has_densify_params(&self) -> bool {
        self.densify_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_densify_params(&mut self, v: GeometryRequest_DensifyParams) {
        self.densify_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_densify_params(&mut self) -> &mut GeometryRequest_DensifyParams {
        if self.densify_params.is_none() {
            self.densify_params.set_default();
        }
        self.densify_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_densify_params(&mut self) -> GeometryRequest_DensifyParams {
        self.densify_params.take().unwrap_or_else(|| GeometryRequest_DensifyParams::new())
    }

    // .epl.protobuf.GeometryRequest.SimplifyParams simplify_params = 21;


    pub fn get_simplify_params(&self) -> &GeometryRequest_SimplifyParams {
        self.simplify_params.as_ref().unwrap_or_else(|| GeometryRequest_SimplifyParams::default_instance())
    }
    pub fn clear_simplify_params(&mut self) {
        self.simplify_params.clear();
    }

    pub fn has_simplify_params(&self) -> bool {
        self.simplify_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simplify_params(&mut self, v: GeometryRequest_SimplifyParams) {
        self.simplify_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_simplify_params(&mut self) -> &mut GeometryRequest_SimplifyParams {
        if self.simplify_params.is_none() {
            self.simplify_params.set_default();
        }
        self.simplify_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_simplify_params(&mut self) -> GeometryRequest_SimplifyParams {
        self.simplify_params.take().unwrap_or_else(|| GeometryRequest_SimplifyParams::new())
    }

    // .epl.protobuf.GeometryRequest.GeneralizeByAreaParams generalize_by_area_params = 22;


    pub fn get_generalize_by_area_params(&self) -> &GeometryRequest_GeneralizeByAreaParams {
        self.generalize_by_area_params.as_ref().unwrap_or_else(|| GeometryRequest_GeneralizeByAreaParams::default_instance())
    }
    pub fn clear_generalize_by_area_params(&mut self) {
        self.generalize_by_area_params.clear();
    }

    pub fn has_generalize_by_area_params(&self) -> bool {
        self.generalize_by_area_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generalize_by_area_params(&mut self, v: GeometryRequest_GeneralizeByAreaParams) {
        self.generalize_by_area_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generalize_by_area_params(&mut self) -> &mut GeometryRequest_GeneralizeByAreaParams {
        if self.generalize_by_area_params.is_none() {
            self.generalize_by_area_params.set_default();
        }
        self.generalize_by_area_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_generalize_by_area_params(&mut self) -> GeometryRequest_GeneralizeByAreaParams {
        self.generalize_by_area_params.take().unwrap_or_else(|| GeometryRequest_GeneralizeByAreaParams::new())
    }

    // .epl.protobuf.GeometryRequest.AffineTransformParams affine_transform_params = 23;


    pub fn get_affine_transform_params(&self) -> &GeometryRequest_AffineTransformParams {
        self.affine_transform_params.as_ref().unwrap_or_else(|| GeometryRequest_AffineTransformParams::default_instance())
    }
    pub fn clear_affine_transform_params(&mut self) {
        self.affine_transform_params.clear();
    }

    pub fn has_affine_transform_params(&self) -> bool {
        self.affine_transform_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affine_transform_params(&mut self, v: GeometryRequest_AffineTransformParams) {
        self.affine_transform_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_affine_transform_params(&mut self) -> &mut GeometryRequest_AffineTransformParams {
        if self.affine_transform_params.is_none() {
            self.affine_transform_params.set_default();
        }
        self.affine_transform_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_affine_transform_params(&mut self) -> GeometryRequest_AffineTransformParams {
        self.affine_transform_params.take().unwrap_or_else(|| GeometryRequest_AffineTransformParams::new())
    }
}

impl ::protobuf::Message for GeometryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.left_geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geometry_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.left_geometry_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right_geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right_geometry_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_sr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result_sr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffer_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.convex_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relate_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.random_points_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generalize_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.intersection_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offset_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cut_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clip_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.densify_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.simplify_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generalize_by_area_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.affine_transform_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left_geometry)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry_request)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left_geometry_request)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right_geometry)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right_geometry_request)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.operator, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result_encoding, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operation_sr)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result_sr)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buffer_params)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.convex_params)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.relate_params)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.random_points_params)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generalize_params)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.intersection_params)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offset_params)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cut_params)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clip_params)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.densify_params)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.simplify_params)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generalize_by_area_params)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.affine_transform_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.left_geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.geometry_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.left_geometry_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right_geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right_geometry_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.operator != OperatorType::UNKNOWN_OPERATOR {
            my_size += ::protobuf::rt::enum_size(7, self.operator);
        }
        if self.result_encoding != Encoding::UNKNOWN_ENCODING {
            my_size += ::protobuf::rt::enum_size(8, self.result_encoding);
        }
        if let Some(ref v) = self.operation_sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result_sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buffer_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.convex_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.relate_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.random_points_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generalize_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.intersection_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.offset_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cut_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clip_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.densify_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.simplify_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generalize_by_area_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.affine_transform_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.geometry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.left_geometry.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.geometry_request.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.left_geometry_request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right_geometry.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right_geometry_request.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.operator != OperatorType::UNKNOWN_OPERATOR {
            os.write_enum(7, self.operator.value())?;
        }
        if self.result_encoding != Encoding::UNKNOWN_ENCODING {
            os.write_enum(8, self.result_encoding.value())?;
        }
        if let Some(ref v) = self.operation_sr.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result_sr.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buffer_params.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.convex_params.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.relate_params.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.random_points_params.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generalize_params.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.intersection_params.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.offset_params.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cut_params.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clip_params.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.densify_params.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.simplify_params.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generalize_by_area_params.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.affine_transform_params.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest {
        GeometryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryData>>(
                    "geometry",
                    |m: &GeometryRequest| { &m.geometry },
                    |m: &mut GeometryRequest| { &mut m.geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryData>>(
                    "left_geometry",
                    |m: &GeometryRequest| { &m.left_geometry },
                    |m: &mut GeometryRequest| { &mut m.left_geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest>>(
                    "geometry_request",
                    |m: &GeometryRequest| { &m.geometry_request },
                    |m: &mut GeometryRequest| { &mut m.geometry_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest>>(
                    "left_geometry_request",
                    |m: &GeometryRequest| { &m.left_geometry_request },
                    |m: &mut GeometryRequest| { &mut m.left_geometry_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryData>>(
                    "right_geometry",
                    |m: &GeometryRequest| { &m.right_geometry },
                    |m: &mut GeometryRequest| { &mut m.right_geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest>>(
                    "right_geometry_request",
                    |m: &GeometryRequest| { &m.right_geometry_request },
                    |m: &mut GeometryRequest| { &mut m.right_geometry_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperatorType>>(
                    "operator",
                    |m: &GeometryRequest| { &m.operator },
                    |m: &mut GeometryRequest| { &mut m.operator },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Encoding>>(
                    "result_encoding",
                    |m: &GeometryRequest| { &m.result_encoding },
                    |m: &mut GeometryRequest| { &mut m.result_encoding },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData>>(
                    "operation_sr",
                    |m: &GeometryRequest| { &m.operation_sr },
                    |m: &mut GeometryRequest| { &mut m.operation_sr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData>>(
                    "result_sr",
                    |m: &GeometryRequest| { &m.result_sr },
                    |m: &mut GeometryRequest| { &mut m.result_sr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_BufferParams>>(
                    "buffer_params",
                    |m: &GeometryRequest| { &m.buffer_params },
                    |m: &mut GeometryRequest| { &mut m.buffer_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_ConvexParams>>(
                    "convex_params",
                    |m: &GeometryRequest| { &m.convex_params },
                    |m: &mut GeometryRequest| { &mut m.convex_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_RelateParams>>(
                    "relate_params",
                    |m: &GeometryRequest| { &m.relate_params },
                    |m: &mut GeometryRequest| { &mut m.relate_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_RandomPointsParams>>(
                    "random_points_params",
                    |m: &GeometryRequest| { &m.random_points_params },
                    |m: &mut GeometryRequest| { &mut m.random_points_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_GeneralizeParams>>(
                    "generalize_params",
                    |m: &GeometryRequest| { &m.generalize_params },
                    |m: &mut GeometryRequest| { &mut m.generalize_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_IntersectionParams>>(
                    "intersection_params",
                    |m: &GeometryRequest| { &m.intersection_params },
                    |m: &mut GeometryRequest| { &mut m.intersection_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_OffsetParams>>(
                    "offset_params",
                    |m: &GeometryRequest| { &m.offset_params },
                    |m: &mut GeometryRequest| { &mut m.offset_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_CutParams>>(
                    "cut_params",
                    |m: &GeometryRequest| { &m.cut_params },
                    |m: &mut GeometryRequest| { &mut m.cut_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_ClipParams>>(
                    "clip_params",
                    |m: &GeometryRequest| { &m.clip_params },
                    |m: &mut GeometryRequest| { &mut m.clip_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_DensifyParams>>(
                    "densify_params",
                    |m: &GeometryRequest| { &m.densify_params },
                    |m: &mut GeometryRequest| { &mut m.densify_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_SimplifyParams>>(
                    "simplify_params",
                    |m: &GeometryRequest| { &m.simplify_params },
                    |m: &mut GeometryRequest| { &mut m.simplify_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_GeneralizeByAreaParams>>(
                    "generalize_by_area_params",
                    |m: &GeometryRequest| { &m.generalize_by_area_params },
                    |m: &mut GeometryRequest| { &mut m.generalize_by_area_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest_AffineTransformParams>>(
                    "affine_transform_params",
                    |m: &GeometryRequest| { &m.affine_transform_params },
                    |m: &mut GeometryRequest| { &mut m.affine_transform_params },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest>(
                    "GeometryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest,
        };
        unsafe {
            instance.get(GeometryRequest::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest {
    fn clear(&mut self) {
        self.geometry.clear();
        self.left_geometry.clear();
        self.geometry_request.clear();
        self.left_geometry_request.clear();
        self.right_geometry.clear();
        self.right_geometry_request.clear();
        self.operator = OperatorType::UNKNOWN_OPERATOR;
        self.result_encoding = Encoding::UNKNOWN_ENCODING;
        self.operation_sr.clear();
        self.result_sr.clear();
        self.buffer_params.clear();
        self.convex_params.clear();
        self.relate_params.clear();
        self.random_points_params.clear();
        self.generalize_params.clear();
        self.intersection_params.clear();
        self.offset_params.clear();
        self.cut_params.clear();
        self.clip_params.clear();
        self.densify_params.clear();
        self.simplify_params.clear();
        self.generalize_by_area_params.clear();
        self.affine_transform_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_BufferParams {
    // message fields
    pub distance: f64,
    pub max_deviation: f64,
    pub union_result: bool,
    pub max_vertices_in_full_circle: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_BufferParams {
    fn default() -> &'a GeometryRequest_BufferParams {
        <GeometryRequest_BufferParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_BufferParams {
    pub fn new() -> GeometryRequest_BufferParams {
        ::std::default::Default::default()
    }

    // double distance = 1;


    pub fn get_distance(&self) -> f64 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f64) {
        self.distance = v;
    }

    // double max_deviation = 2;


    pub fn get_max_deviation(&self) -> f64 {
        self.max_deviation
    }
    pub fn clear_max_deviation(&mut self) {
        self.max_deviation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_deviation(&mut self, v: f64) {
        self.max_deviation = v;
    }

    // bool union_result = 3;


    pub fn get_union_result(&self) -> bool {
        self.union_result
    }
    pub fn clear_union_result(&mut self) {
        self.union_result = false;
    }

    // Param is passed by value, moved
    pub fn set_union_result(&mut self, v: bool) {
        self.union_result = v;
    }

    // int32 max_vertices_in_full_circle = 4;


    pub fn get_max_vertices_in_full_circle(&self) -> i32 {
        self.max_vertices_in_full_circle
    }
    pub fn clear_max_vertices_in_full_circle(&mut self) {
        self.max_vertices_in_full_circle = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_vertices_in_full_circle(&mut self, v: i32) {
        self.max_vertices_in_full_circle = v;
    }
}

impl ::protobuf::Message for GeometryRequest_BufferParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max_deviation = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.union_result = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_vertices_in_full_circle = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.distance != 0. {
            my_size += 9;
        }
        if self.max_deviation != 0. {
            my_size += 9;
        }
        if self.union_result != false {
            my_size += 2;
        }
        if self.max_vertices_in_full_circle != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_vertices_in_full_circle, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.distance != 0. {
            os.write_double(1, self.distance)?;
        }
        if self.max_deviation != 0. {
            os.write_double(2, self.max_deviation)?;
        }
        if self.union_result != false {
            os.write_bool(3, self.union_result)?;
        }
        if self.max_vertices_in_full_circle != 0 {
            os.write_int32(4, self.max_vertices_in_full_circle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_BufferParams {
        GeometryRequest_BufferParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "distance",
                    |m: &GeometryRequest_BufferParams| { &m.distance },
                    |m: &mut GeometryRequest_BufferParams| { &mut m.distance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "max_deviation",
                    |m: &GeometryRequest_BufferParams| { &m.max_deviation },
                    |m: &mut GeometryRequest_BufferParams| { &mut m.max_deviation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "union_result",
                    |m: &GeometryRequest_BufferParams| { &m.union_result },
                    |m: &mut GeometryRequest_BufferParams| { &mut m.union_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_vertices_in_full_circle",
                    |m: &GeometryRequest_BufferParams| { &m.max_vertices_in_full_circle },
                    |m: &mut GeometryRequest_BufferParams| { &mut m.max_vertices_in_full_circle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_BufferParams>(
                    "GeometryRequest_BufferParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_BufferParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_BufferParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_BufferParams,
        };
        unsafe {
            instance.get(GeometryRequest_BufferParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_BufferParams {
    fn clear(&mut self) {
        self.distance = 0.;
        self.max_deviation = 0.;
        self.union_result = false;
        self.max_vertices_in_full_circle = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_BufferParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_BufferParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_GeodeticBufferParams {
    // message fields
    pub distance: f64,
    pub max_deviation: f64,
    pub union_result: bool,
    pub max_vertices_in_full_circle: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_GeodeticBufferParams {
    fn default() -> &'a GeometryRequest_GeodeticBufferParams {
        <GeometryRequest_GeodeticBufferParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_GeodeticBufferParams {
    pub fn new() -> GeometryRequest_GeodeticBufferParams {
        ::std::default::Default::default()
    }

    // double distance = 1;


    pub fn get_distance(&self) -> f64 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f64) {
        self.distance = v;
    }

    // double max_deviation = 2;


    pub fn get_max_deviation(&self) -> f64 {
        self.max_deviation
    }
    pub fn clear_max_deviation(&mut self) {
        self.max_deviation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_deviation(&mut self, v: f64) {
        self.max_deviation = v;
    }

    // bool union_result = 3;


    pub fn get_union_result(&self) -> bool {
        self.union_result
    }
    pub fn clear_union_result(&mut self) {
        self.union_result = false;
    }

    // Param is passed by value, moved
    pub fn set_union_result(&mut self, v: bool) {
        self.union_result = v;
    }

    // int32 max_vertices_in_full_circle = 4;


    pub fn get_max_vertices_in_full_circle(&self) -> i32 {
        self.max_vertices_in_full_circle
    }
    pub fn clear_max_vertices_in_full_circle(&mut self) {
        self.max_vertices_in_full_circle = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_vertices_in_full_circle(&mut self, v: i32) {
        self.max_vertices_in_full_circle = v;
    }
}

impl ::protobuf::Message for GeometryRequest_GeodeticBufferParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max_deviation = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.union_result = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_vertices_in_full_circle = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.distance != 0. {
            my_size += 9;
        }
        if self.max_deviation != 0. {
            my_size += 9;
        }
        if self.union_result != false {
            my_size += 2;
        }
        if self.max_vertices_in_full_circle != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_vertices_in_full_circle, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.distance != 0. {
            os.write_double(1, self.distance)?;
        }
        if self.max_deviation != 0. {
            os.write_double(2, self.max_deviation)?;
        }
        if self.union_result != false {
            os.write_bool(3, self.union_result)?;
        }
        if self.max_vertices_in_full_circle != 0 {
            os.write_int32(4, self.max_vertices_in_full_circle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_GeodeticBufferParams {
        GeometryRequest_GeodeticBufferParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "distance",
                    |m: &GeometryRequest_GeodeticBufferParams| { &m.distance },
                    |m: &mut GeometryRequest_GeodeticBufferParams| { &mut m.distance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "max_deviation",
                    |m: &GeometryRequest_GeodeticBufferParams| { &m.max_deviation },
                    |m: &mut GeometryRequest_GeodeticBufferParams| { &mut m.max_deviation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "union_result",
                    |m: &GeometryRequest_GeodeticBufferParams| { &m.union_result },
                    |m: &mut GeometryRequest_GeodeticBufferParams| { &mut m.union_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_vertices_in_full_circle",
                    |m: &GeometryRequest_GeodeticBufferParams| { &m.max_vertices_in_full_circle },
                    |m: &mut GeometryRequest_GeodeticBufferParams| { &mut m.max_vertices_in_full_circle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_GeodeticBufferParams>(
                    "GeometryRequest_GeodeticBufferParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_GeodeticBufferParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_GeodeticBufferParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_GeodeticBufferParams,
        };
        unsafe {
            instance.get(GeometryRequest_GeodeticBufferParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_GeodeticBufferParams {
    fn clear(&mut self) {
        self.distance = 0.;
        self.max_deviation = 0.;
        self.union_result = false;
        self.max_vertices_in_full_circle = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_GeodeticBufferParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_GeodeticBufferParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_ConvexParams {
    // message fields
    pub merge: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_ConvexParams {
    fn default() -> &'a GeometryRequest_ConvexParams {
        <GeometryRequest_ConvexParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_ConvexParams {
    pub fn new() -> GeometryRequest_ConvexParams {
        ::std::default::Default::default()
    }

    // bool merge = 1;


    pub fn get_merge(&self) -> bool {
        self.merge
    }
    pub fn clear_merge(&mut self) {
        self.merge = false;
    }

    // Param is passed by value, moved
    pub fn set_merge(&mut self, v: bool) {
        self.merge = v;
    }
}

impl ::protobuf::Message for GeometryRequest_ConvexParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.merge = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.merge != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.merge != false {
            os.write_bool(1, self.merge)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_ConvexParams {
        GeometryRequest_ConvexParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "merge",
                    |m: &GeometryRequest_ConvexParams| { &m.merge },
                    |m: &mut GeometryRequest_ConvexParams| { &mut m.merge },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_ConvexParams>(
                    "GeometryRequest_ConvexParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_ConvexParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_ConvexParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_ConvexParams,
        };
        unsafe {
            instance.get(GeometryRequest_ConvexParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_ConvexParams {
    fn clear(&mut self) {
        self.merge = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_ConvexParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_ConvexParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_RelateParams {
    // message fields
    pub de_9im: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_RelateParams {
    fn default() -> &'a GeometryRequest_RelateParams {
        <GeometryRequest_RelateParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_RelateParams {
    pub fn new() -> GeometryRequest_RelateParams {
        ::std::default::Default::default()
    }

    // string de_9im = 1;


    pub fn get_de_9im(&self) -> &str {
        &self.de_9im
    }
    pub fn clear_de_9im(&mut self) {
        self.de_9im.clear();
    }

    // Param is passed by value, moved
    pub fn set_de_9im(&mut self, v: ::std::string::String) {
        self.de_9im = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_de_9im(&mut self) -> &mut ::std::string::String {
        &mut self.de_9im
    }

    // Take field
    pub fn take_de_9im(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.de_9im, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GeometryRequest_RelateParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.de_9im)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.de_9im.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.de_9im);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.de_9im.is_empty() {
            os.write_string(1, &self.de_9im)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_RelateParams {
        GeometryRequest_RelateParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "de_9im",
                    |m: &GeometryRequest_RelateParams| { &m.de_9im },
                    |m: &mut GeometryRequest_RelateParams| { &mut m.de_9im },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_RelateParams>(
                    "GeometryRequest_RelateParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_RelateParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_RelateParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_RelateParams,
        };
        unsafe {
            instance.get(GeometryRequest_RelateParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_RelateParams {
    fn clear(&mut self) {
        self.de_9im.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_RelateParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_RelateParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_RandomPointsParams {
    // message fields
    pub points_per_square_km: f64,
    pub seed: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_RandomPointsParams {
    fn default() -> &'a GeometryRequest_RandomPointsParams {
        <GeometryRequest_RandomPointsParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_RandomPointsParams {
    pub fn new() -> GeometryRequest_RandomPointsParams {
        ::std::default::Default::default()
    }

    // double points_per_square_km = 1;


    pub fn get_points_per_square_km(&self) -> f64 {
        self.points_per_square_km
    }
    pub fn clear_points_per_square_km(&mut self) {
        self.points_per_square_km = 0.;
    }

    // Param is passed by value, moved
    pub fn set_points_per_square_km(&mut self, v: f64) {
        self.points_per_square_km = v;
    }

    // int64 seed = 2;


    pub fn get_seed(&self) -> i64 {
        self.seed
    }
    pub fn clear_seed(&mut self) {
        self.seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: i64) {
        self.seed = v;
    }
}

impl ::protobuf::Message for GeometryRequest_RandomPointsParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.points_per_square_km = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.points_per_square_km != 0. {
            my_size += 9;
        }
        if self.seed != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seed, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.points_per_square_km != 0. {
            os.write_double(1, self.points_per_square_km)?;
        }
        if self.seed != 0 {
            os.write_int64(2, self.seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_RandomPointsParams {
        GeometryRequest_RandomPointsParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "points_per_square_km",
                    |m: &GeometryRequest_RandomPointsParams| { &m.points_per_square_km },
                    |m: &mut GeometryRequest_RandomPointsParams| { &mut m.points_per_square_km },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seed",
                    |m: &GeometryRequest_RandomPointsParams| { &m.seed },
                    |m: &mut GeometryRequest_RandomPointsParams| { &mut m.seed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_RandomPointsParams>(
                    "GeometryRequest_RandomPointsParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_RandomPointsParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_RandomPointsParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_RandomPointsParams,
        };
        unsafe {
            instance.get(GeometryRequest_RandomPointsParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_RandomPointsParams {
    fn clear(&mut self) {
        self.points_per_square_km = 0.;
        self.seed = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_RandomPointsParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_RandomPointsParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_GeneralizeParams {
    // message fields
    pub max_deviation: f64,
    pub remove_degenerates: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_GeneralizeParams {
    fn default() -> &'a GeometryRequest_GeneralizeParams {
        <GeometryRequest_GeneralizeParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_GeneralizeParams {
    pub fn new() -> GeometryRequest_GeneralizeParams {
        ::std::default::Default::default()
    }

    // double max_deviation = 1;


    pub fn get_max_deviation(&self) -> f64 {
        self.max_deviation
    }
    pub fn clear_max_deviation(&mut self) {
        self.max_deviation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_deviation(&mut self, v: f64) {
        self.max_deviation = v;
    }

    // bool remove_degenerates = 2;


    pub fn get_remove_degenerates(&self) -> bool {
        self.remove_degenerates
    }
    pub fn clear_remove_degenerates(&mut self) {
        self.remove_degenerates = false;
    }

    // Param is passed by value, moved
    pub fn set_remove_degenerates(&mut self, v: bool) {
        self.remove_degenerates = v;
    }
}

impl ::protobuf::Message for GeometryRequest_GeneralizeParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max_deviation = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove_degenerates = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_deviation != 0. {
            my_size += 9;
        }
        if self.remove_degenerates != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_deviation != 0. {
            os.write_double(1, self.max_deviation)?;
        }
        if self.remove_degenerates != false {
            os.write_bool(2, self.remove_degenerates)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_GeneralizeParams {
        GeometryRequest_GeneralizeParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "max_deviation",
                    |m: &GeometryRequest_GeneralizeParams| { &m.max_deviation },
                    |m: &mut GeometryRequest_GeneralizeParams| { &mut m.max_deviation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remove_degenerates",
                    |m: &GeometryRequest_GeneralizeParams| { &m.remove_degenerates },
                    |m: &mut GeometryRequest_GeneralizeParams| { &mut m.remove_degenerates },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_GeneralizeParams>(
                    "GeometryRequest_GeneralizeParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_GeneralizeParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_GeneralizeParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_GeneralizeParams,
        };
        unsafe {
            instance.get(GeometryRequest_GeneralizeParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_GeneralizeParams {
    fn clear(&mut self) {
        self.max_deviation = 0.;
        self.remove_degenerates = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_GeneralizeParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_GeneralizeParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_GeneralizeByAreaParams {
    // message fields
    pub percent_reduction: f64,
    pub remove_degenerates: bool,
    pub max_point_count: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_GeneralizeByAreaParams {
    fn default() -> &'a GeometryRequest_GeneralizeByAreaParams {
        <GeometryRequest_GeneralizeByAreaParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_GeneralizeByAreaParams {
    pub fn new() -> GeometryRequest_GeneralizeByAreaParams {
        ::std::default::Default::default()
    }

    // double percent_reduction = 1;


    pub fn get_percent_reduction(&self) -> f64 {
        self.percent_reduction
    }
    pub fn clear_percent_reduction(&mut self) {
        self.percent_reduction = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percent_reduction(&mut self, v: f64) {
        self.percent_reduction = v;
    }

    // bool remove_degenerates = 2;


    pub fn get_remove_degenerates(&self) -> bool {
        self.remove_degenerates
    }
    pub fn clear_remove_degenerates(&mut self) {
        self.remove_degenerates = false;
    }

    // Param is passed by value, moved
    pub fn set_remove_degenerates(&mut self, v: bool) {
        self.remove_degenerates = v;
    }

    // int32 max_point_count = 3;


    pub fn get_max_point_count(&self) -> i32 {
        self.max_point_count
    }
    pub fn clear_max_point_count(&mut self) {
        self.max_point_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_point_count(&mut self, v: i32) {
        self.max_point_count = v;
    }
}

impl ::protobuf::Message for GeometryRequest_GeneralizeByAreaParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.percent_reduction = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove_degenerates = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_point_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.percent_reduction != 0. {
            my_size += 9;
        }
        if self.remove_degenerates != false {
            my_size += 2;
        }
        if self.max_point_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_point_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.percent_reduction != 0. {
            os.write_double(1, self.percent_reduction)?;
        }
        if self.remove_degenerates != false {
            os.write_bool(2, self.remove_degenerates)?;
        }
        if self.max_point_count != 0 {
            os.write_int32(3, self.max_point_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_GeneralizeByAreaParams {
        GeometryRequest_GeneralizeByAreaParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "percent_reduction",
                    |m: &GeometryRequest_GeneralizeByAreaParams| { &m.percent_reduction },
                    |m: &mut GeometryRequest_GeneralizeByAreaParams| { &mut m.percent_reduction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remove_degenerates",
                    |m: &GeometryRequest_GeneralizeByAreaParams| { &m.remove_degenerates },
                    |m: &mut GeometryRequest_GeneralizeByAreaParams| { &mut m.remove_degenerates },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_point_count",
                    |m: &GeometryRequest_GeneralizeByAreaParams| { &m.max_point_count },
                    |m: &mut GeometryRequest_GeneralizeByAreaParams| { &mut m.max_point_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_GeneralizeByAreaParams>(
                    "GeometryRequest_GeneralizeByAreaParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_GeneralizeByAreaParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_GeneralizeByAreaParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_GeneralizeByAreaParams,
        };
        unsafe {
            instance.get(GeometryRequest_GeneralizeByAreaParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_GeneralizeByAreaParams {
    fn clear(&mut self) {
        self.percent_reduction = 0.;
        self.remove_degenerates = false;
        self.max_point_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_GeneralizeByAreaParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_GeneralizeByAreaParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_IntersectionParams {
    // message fields
    pub dimension_mask: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_IntersectionParams {
    fn default() -> &'a GeometryRequest_IntersectionParams {
        <GeometryRequest_IntersectionParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_IntersectionParams {
    pub fn new() -> GeometryRequest_IntersectionParams {
        ::std::default::Default::default()
    }

    // int32 dimension_mask = 1;


    pub fn get_dimension_mask(&self) -> i32 {
        self.dimension_mask
    }
    pub fn clear_dimension_mask(&mut self) {
        self.dimension_mask = 0;
    }

    // Param is passed by value, moved
    pub fn set_dimension_mask(&mut self, v: i32) {
        self.dimension_mask = v;
    }
}

impl ::protobuf::Message for GeometryRequest_IntersectionParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dimension_mask = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dimension_mask != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dimension_mask, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dimension_mask != 0 {
            os.write_int32(1, self.dimension_mask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_IntersectionParams {
        GeometryRequest_IntersectionParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dimension_mask",
                    |m: &GeometryRequest_IntersectionParams| { &m.dimension_mask },
                    |m: &mut GeometryRequest_IntersectionParams| { &mut m.dimension_mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_IntersectionParams>(
                    "GeometryRequest_IntersectionParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_IntersectionParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_IntersectionParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_IntersectionParams,
        };
        unsafe {
            instance.get(GeometryRequest_IntersectionParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_IntersectionParams {
    fn clear(&mut self) {
        self.dimension_mask = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_IntersectionParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_IntersectionParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_OffsetParams {
    // message fields
    pub distance: f64,
    pub join_type: GeometryRequest_OffsetParams_OffsetJoinType,
    pub bevel_ratio: f64,
    pub flatten_error: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_OffsetParams {
    fn default() -> &'a GeometryRequest_OffsetParams {
        <GeometryRequest_OffsetParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_OffsetParams {
    pub fn new() -> GeometryRequest_OffsetParams {
        ::std::default::Default::default()
    }

    // double distance = 1;


    pub fn get_distance(&self) -> f64 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f64) {
        self.distance = v;
    }

    // .epl.protobuf.GeometryRequest.OffsetParams.OffsetJoinType join_type = 2;


    pub fn get_join_type(&self) -> GeometryRequest_OffsetParams_OffsetJoinType {
        self.join_type
    }
    pub fn clear_join_type(&mut self) {
        self.join_type = GeometryRequest_OffsetParams_OffsetJoinType::ROUND;
    }

    // Param is passed by value, moved
    pub fn set_join_type(&mut self, v: GeometryRequest_OffsetParams_OffsetJoinType) {
        self.join_type = v;
    }

    // double bevel_ratio = 3;


    pub fn get_bevel_ratio(&self) -> f64 {
        self.bevel_ratio
    }
    pub fn clear_bevel_ratio(&mut self) {
        self.bevel_ratio = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bevel_ratio(&mut self, v: f64) {
        self.bevel_ratio = v;
    }

    // double flatten_error = 4;


    pub fn get_flatten_error(&self) -> f64 {
        self.flatten_error
    }
    pub fn clear_flatten_error(&mut self) {
        self.flatten_error = 0.;
    }

    // Param is passed by value, moved
    pub fn set_flatten_error(&mut self, v: f64) {
        self.flatten_error = v;
    }
}

impl ::protobuf::Message for GeometryRequest_OffsetParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distance = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.join_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bevel_ratio = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.flatten_error = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.distance != 0. {
            my_size += 9;
        }
        if self.join_type != GeometryRequest_OffsetParams_OffsetJoinType::ROUND {
            my_size += ::protobuf::rt::enum_size(2, self.join_type);
        }
        if self.bevel_ratio != 0. {
            my_size += 9;
        }
        if self.flatten_error != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.distance != 0. {
            os.write_double(1, self.distance)?;
        }
        if self.join_type != GeometryRequest_OffsetParams_OffsetJoinType::ROUND {
            os.write_enum(2, self.join_type.value())?;
        }
        if self.bevel_ratio != 0. {
            os.write_double(3, self.bevel_ratio)?;
        }
        if self.flatten_error != 0. {
            os.write_double(4, self.flatten_error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_OffsetParams {
        GeometryRequest_OffsetParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "distance",
                    |m: &GeometryRequest_OffsetParams| { &m.distance },
                    |m: &mut GeometryRequest_OffsetParams| { &mut m.distance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GeometryRequest_OffsetParams_OffsetJoinType>>(
                    "join_type",
                    |m: &GeometryRequest_OffsetParams| { &m.join_type },
                    |m: &mut GeometryRequest_OffsetParams| { &mut m.join_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "bevel_ratio",
                    |m: &GeometryRequest_OffsetParams| { &m.bevel_ratio },
                    |m: &mut GeometryRequest_OffsetParams| { &mut m.bevel_ratio },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "flatten_error",
                    |m: &GeometryRequest_OffsetParams| { &m.flatten_error },
                    |m: &mut GeometryRequest_OffsetParams| { &mut m.flatten_error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_OffsetParams>(
                    "GeometryRequest_OffsetParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_OffsetParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_OffsetParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_OffsetParams,
        };
        unsafe {
            instance.get(GeometryRequest_OffsetParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_OffsetParams {
    fn clear(&mut self) {
        self.distance = 0.;
        self.join_type = GeometryRequest_OffsetParams_OffsetJoinType::ROUND;
        self.bevel_ratio = 0.;
        self.flatten_error = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_OffsetParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_OffsetParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum GeometryRequest_OffsetParams_OffsetJoinType {
    ROUND = 0,
    BEVEL = 1,
    MITER = 2,
    SQUARE = 3,
}

impl ::protobuf::ProtobufEnum for GeometryRequest_OffsetParams_OffsetJoinType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GeometryRequest_OffsetParams_OffsetJoinType> {
        match value {
            0 => ::std::option::Option::Some(GeometryRequest_OffsetParams_OffsetJoinType::ROUND),
            1 => ::std::option::Option::Some(GeometryRequest_OffsetParams_OffsetJoinType::BEVEL),
            2 => ::std::option::Option::Some(GeometryRequest_OffsetParams_OffsetJoinType::MITER),
            3 => ::std::option::Option::Some(GeometryRequest_OffsetParams_OffsetJoinType::SQUARE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GeometryRequest_OffsetParams_OffsetJoinType] = &[
            GeometryRequest_OffsetParams_OffsetJoinType::ROUND,
            GeometryRequest_OffsetParams_OffsetJoinType::BEVEL,
            GeometryRequest_OffsetParams_OffsetJoinType::MITER,
            GeometryRequest_OffsetParams_OffsetJoinType::SQUARE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GeometryRequest_OffsetParams_OffsetJoinType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GeometryRequest_OffsetParams_OffsetJoinType {
}

impl ::std::default::Default for GeometryRequest_OffsetParams_OffsetJoinType {
    fn default() -> Self {
        GeometryRequest_OffsetParams_OffsetJoinType::ROUND
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_OffsetParams_OffsetJoinType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_CutParams {
    // message fields
    pub consider_touch: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_CutParams {
    fn default() -> &'a GeometryRequest_CutParams {
        <GeometryRequest_CutParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_CutParams {
    pub fn new() -> GeometryRequest_CutParams {
        ::std::default::Default::default()
    }

    // bool consider_touch = 1;


    pub fn get_consider_touch(&self) -> bool {
        self.consider_touch
    }
    pub fn clear_consider_touch(&mut self) {
        self.consider_touch = false;
    }

    // Param is passed by value, moved
    pub fn set_consider_touch(&mut self, v: bool) {
        self.consider_touch = v;
    }
}

impl ::protobuf::Message for GeometryRequest_CutParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.consider_touch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.consider_touch != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.consider_touch != false {
            os.write_bool(1, self.consider_touch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_CutParams {
        GeometryRequest_CutParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "consider_touch",
                    |m: &GeometryRequest_CutParams| { &m.consider_touch },
                    |m: &mut GeometryRequest_CutParams| { &mut m.consider_touch },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_CutParams>(
                    "GeometryRequest_CutParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_CutParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_CutParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_CutParams,
        };
        unsafe {
            instance.get(GeometryRequest_CutParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_CutParams {
    fn clear(&mut self) {
        self.consider_touch = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_CutParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_CutParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_ClipParams {
    // message fields
    pub envelope: ::protobuf::SingularPtrField<EnvelopeData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_ClipParams {
    fn default() -> &'a GeometryRequest_ClipParams {
        <GeometryRequest_ClipParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_ClipParams {
    pub fn new() -> GeometryRequest_ClipParams {
        ::std::default::Default::default()
    }

    // .epl.protobuf.EnvelopeData envelope = 1;


    pub fn get_envelope(&self) -> &EnvelopeData {
        self.envelope.as_ref().unwrap_or_else(|| EnvelopeData::default_instance())
    }
    pub fn clear_envelope(&mut self) {
        self.envelope.clear();
    }

    pub fn has_envelope(&self) -> bool {
        self.envelope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_envelope(&mut self, v: EnvelopeData) {
        self.envelope = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_envelope(&mut self) -> &mut EnvelopeData {
        if self.envelope.is_none() {
            self.envelope.set_default();
        }
        self.envelope.as_mut().unwrap()
    }

    // Take field
    pub fn take_envelope(&mut self) -> EnvelopeData {
        self.envelope.take().unwrap_or_else(|| EnvelopeData::new())
    }
}

impl ::protobuf::Message for GeometryRequest_ClipParams {
    fn is_initialized(&self) -> bool {
        for v in &self.envelope {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.envelope)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.envelope.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.envelope.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_ClipParams {
        GeometryRequest_ClipParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvelopeData>>(
                    "envelope",
                    |m: &GeometryRequest_ClipParams| { &m.envelope },
                    |m: &mut GeometryRequest_ClipParams| { &mut m.envelope },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_ClipParams>(
                    "GeometryRequest_ClipParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_ClipParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_ClipParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_ClipParams,
        };
        unsafe {
            instance.get(GeometryRequest_ClipParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_ClipParams {
    fn clear(&mut self) {
        self.envelope.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_ClipParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_ClipParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_DensifyParams {
    // message fields
    pub max_length: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_DensifyParams {
    fn default() -> &'a GeometryRequest_DensifyParams {
        <GeometryRequest_DensifyParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_DensifyParams {
    pub fn new() -> GeometryRequest_DensifyParams {
        ::std::default::Default::default()
    }

    // double max_length = 1;


    pub fn get_max_length(&self) -> f64 {
        self.max_length
    }
    pub fn clear_max_length(&mut self) {
        self.max_length = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_length(&mut self, v: f64) {
        self.max_length = v;
    }
}

impl ::protobuf::Message for GeometryRequest_DensifyParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max_length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_length != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_length != 0. {
            os.write_double(1, self.max_length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_DensifyParams {
        GeometryRequest_DensifyParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "max_length",
                    |m: &GeometryRequest_DensifyParams| { &m.max_length },
                    |m: &mut GeometryRequest_DensifyParams| { &mut m.max_length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_DensifyParams>(
                    "GeometryRequest_DensifyParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_DensifyParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_DensifyParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_DensifyParams,
        };
        unsafe {
            instance.get(GeometryRequest_DensifyParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_DensifyParams {
    fn clear(&mut self) {
        self.max_length = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_DensifyParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_DensifyParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_SimplifyParams {
    // message fields
    pub force: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_SimplifyParams {
    fn default() -> &'a GeometryRequest_SimplifyParams {
        <GeometryRequest_SimplifyParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_SimplifyParams {
    pub fn new() -> GeometryRequest_SimplifyParams {
        ::std::default::Default::default()
    }

    // bool force = 1;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }
}

impl ::protobuf::Message for GeometryRequest_SimplifyParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.force != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.force != false {
            os.write_bool(1, self.force)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_SimplifyParams {
        GeometryRequest_SimplifyParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &GeometryRequest_SimplifyParams| { &m.force },
                    |m: &mut GeometryRequest_SimplifyParams| { &mut m.force },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_SimplifyParams>(
                    "GeometryRequest_SimplifyParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_SimplifyParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_SimplifyParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_SimplifyParams,
        };
        unsafe {
            instance.get(GeometryRequest_SimplifyParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_SimplifyParams {
    fn clear(&mut self) {
        self.force = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_SimplifyParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_SimplifyParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryRequest_AffineTransformParams {
    // message fields
    pub geodetic: bool,
    pub x_offset: f64,
    pub y_offset: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryRequest_AffineTransformParams {
    fn default() -> &'a GeometryRequest_AffineTransformParams {
        <GeometryRequest_AffineTransformParams as ::protobuf::Message>::default_instance()
    }
}

impl GeometryRequest_AffineTransformParams {
    pub fn new() -> GeometryRequest_AffineTransformParams {
        ::std::default::Default::default()
    }

    // bool geodetic = 2;


    pub fn get_geodetic(&self) -> bool {
        self.geodetic
    }
    pub fn clear_geodetic(&mut self) {
        self.geodetic = false;
    }

    // Param is passed by value, moved
    pub fn set_geodetic(&mut self, v: bool) {
        self.geodetic = v;
    }

    // double x_offset = 3;


    pub fn get_x_offset(&self) -> f64 {
        self.x_offset
    }
    pub fn clear_x_offset(&mut self) {
        self.x_offset = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x_offset(&mut self, v: f64) {
        self.x_offset = v;
    }

    // double y_offset = 4;


    pub fn get_y_offset(&self) -> f64 {
        self.y_offset
    }
    pub fn clear_y_offset(&mut self) {
        self.y_offset = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y_offset(&mut self, v: f64) {
        self.y_offset = v;
    }
}

impl ::protobuf::Message for GeometryRequest_AffineTransformParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.geodetic = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.x_offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.y_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.geodetic != false {
            my_size += 2;
        }
        if self.x_offset != 0. {
            my_size += 9;
        }
        if self.y_offset != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.geodetic != false {
            os.write_bool(2, self.geodetic)?;
        }
        if self.x_offset != 0. {
            os.write_double(3, self.x_offset)?;
        }
        if self.y_offset != 0. {
            os.write_double(4, self.y_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryRequest_AffineTransformParams {
        GeometryRequest_AffineTransformParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "geodetic",
                    |m: &GeometryRequest_AffineTransformParams| { &m.geodetic },
                    |m: &mut GeometryRequest_AffineTransformParams| { &mut m.geodetic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "x_offset",
                    |m: &GeometryRequest_AffineTransformParams| { &m.x_offset },
                    |m: &mut GeometryRequest_AffineTransformParams| { &mut m.x_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "y_offset",
                    |m: &GeometryRequest_AffineTransformParams| { &m.y_offset },
                    |m: &mut GeometryRequest_AffineTransformParams| { &mut m.y_offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryRequest_AffineTransformParams>(
                    "GeometryRequest_AffineTransformParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryRequest_AffineTransformParams {
        static mut instance: ::protobuf::lazy::Lazy<GeometryRequest_AffineTransformParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryRequest_AffineTransformParams,
        };
        unsafe {
            instance.get(GeometryRequest_AffineTransformParams::new)
        }
    }
}

impl ::protobuf::Clear for GeometryRequest_AffineTransformParams {
    fn clear(&mut self) {
        self.geodetic = false;
        self.x_offset = 0.;
        self.y_offset = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryRequest_AffineTransformParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryRequest_AffineTransformParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeodeticInverse {
    // message fields
    pub az12: f64,
    pub az21: f64,
    pub distance: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeodeticInverse {
    fn default() -> &'a GeodeticInverse {
        <GeodeticInverse as ::protobuf::Message>::default_instance()
    }
}

impl GeodeticInverse {
    pub fn new() -> GeodeticInverse {
        ::std::default::Default::default()
    }

    // double az12 = 1;


    pub fn get_az12(&self) -> f64 {
        self.az12
    }
    pub fn clear_az12(&mut self) {
        self.az12 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_az12(&mut self, v: f64) {
        self.az12 = v;
    }

    // double az21 = 2;


    pub fn get_az21(&self) -> f64 {
        self.az21
    }
    pub fn clear_az21(&mut self) {
        self.az21 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_az21(&mut self, v: f64) {
        self.az21 = v;
    }

    // double distance = 3;


    pub fn get_distance(&self) -> f64 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f64) {
        self.distance = v;
    }
}

impl ::protobuf::Message for GeodeticInverse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.az12 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.az21 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.az12 != 0. {
            my_size += 9;
        }
        if self.az21 != 0. {
            my_size += 9;
        }
        if self.distance != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.az12 != 0. {
            os.write_double(1, self.az12)?;
        }
        if self.az21 != 0. {
            os.write_double(2, self.az21)?;
        }
        if self.distance != 0. {
            os.write_double(3, self.distance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeodeticInverse {
        GeodeticInverse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "az12",
                    |m: &GeodeticInverse| { &m.az12 },
                    |m: &mut GeodeticInverse| { &mut m.az12 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "az21",
                    |m: &GeodeticInverse| { &m.az21 },
                    |m: &mut GeodeticInverse| { &mut m.az21 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "distance",
                    |m: &GeodeticInverse| { &m.distance },
                    |m: &mut GeodeticInverse| { &mut m.distance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeodeticInverse>(
                    "GeodeticInverse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeodeticInverse {
        static mut instance: ::protobuf::lazy::Lazy<GeodeticInverse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeodeticInverse,
        };
        unsafe {
            instance.get(GeodeticInverse::new)
        }
    }
}

impl ::protobuf::Clear for GeodeticInverse {
    fn clear(&mut self) {
        self.az12 = 0.;
        self.az21 = 0.;
        self.distance = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeodeticInverse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeodeticInverse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeometryResponse {
    // message fields
    pub geometry: ::protobuf::SingularPtrField<GeometryData>,
    pub spatial_relationship: bool,
    pub measure: f64,
    pub relate_map: ::std::collections::HashMap<i64, bool>,
    pub envelope: ::protobuf::SingularPtrField<EnvelopeData>,
    pub geodetic_inverse: ::protobuf::SingularPtrField<GeodeticInverse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeometryResponse {
    fn default() -> &'a GeometryResponse {
        <GeometryResponse as ::protobuf::Message>::default_instance()
    }
}

impl GeometryResponse {
    pub fn new() -> GeometryResponse {
        ::std::default::Default::default()
    }

    // .epl.protobuf.GeometryData geometry = 1;


    pub fn get_geometry(&self) -> &GeometryData {
        self.geometry.as_ref().unwrap_or_else(|| GeometryData::default_instance())
    }
    pub fn clear_geometry(&mut self) {
        self.geometry.clear();
    }

    pub fn has_geometry(&self) -> bool {
        self.geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: GeometryData) {
        self.geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry(&mut self) -> &mut GeometryData {
        if self.geometry.is_none() {
            self.geometry.set_default();
        }
        self.geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry(&mut self) -> GeometryData {
        self.geometry.take().unwrap_or_else(|| GeometryData::new())
    }

    // bool spatial_relationship = 2;


    pub fn get_spatial_relationship(&self) -> bool {
        self.spatial_relationship
    }
    pub fn clear_spatial_relationship(&mut self) {
        self.spatial_relationship = false;
    }

    // Param is passed by value, moved
    pub fn set_spatial_relationship(&mut self, v: bool) {
        self.spatial_relationship = v;
    }

    // double measure = 3;


    pub fn get_measure(&self) -> f64 {
        self.measure
    }
    pub fn clear_measure(&mut self) {
        self.measure = 0.;
    }

    // Param is passed by value, moved
    pub fn set_measure(&mut self, v: f64) {
        self.measure = v;
    }

    // repeated .epl.protobuf.GeometryResponse.RelateMapEntry relate_map = 4;


    pub fn get_relate_map(&self) -> &::std::collections::HashMap<i64, bool> {
        &self.relate_map
    }
    pub fn clear_relate_map(&mut self) {
        self.relate_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_relate_map(&mut self, v: ::std::collections::HashMap<i64, bool>) {
        self.relate_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relate_map(&mut self) -> &mut ::std::collections::HashMap<i64, bool> {
        &mut self.relate_map
    }

    // Take field
    pub fn take_relate_map(&mut self) -> ::std::collections::HashMap<i64, bool> {
        ::std::mem::replace(&mut self.relate_map, ::std::collections::HashMap::new())
    }

    // .epl.protobuf.EnvelopeData envelope = 5;


    pub fn get_envelope(&self) -> &EnvelopeData {
        self.envelope.as_ref().unwrap_or_else(|| EnvelopeData::default_instance())
    }
    pub fn clear_envelope(&mut self) {
        self.envelope.clear();
    }

    pub fn has_envelope(&self) -> bool {
        self.envelope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_envelope(&mut self, v: EnvelopeData) {
        self.envelope = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_envelope(&mut self) -> &mut EnvelopeData {
        if self.envelope.is_none() {
            self.envelope.set_default();
        }
        self.envelope.as_mut().unwrap()
    }

    // Take field
    pub fn take_envelope(&mut self) -> EnvelopeData {
        self.envelope.take().unwrap_or_else(|| EnvelopeData::new())
    }

    // .epl.protobuf.GeodeticInverse geodetic_inverse = 6;


    pub fn get_geodetic_inverse(&self) -> &GeodeticInverse {
        self.geodetic_inverse.as_ref().unwrap_or_else(|| GeodeticInverse::default_instance())
    }
    pub fn clear_geodetic_inverse(&mut self) {
        self.geodetic_inverse.clear();
    }

    pub fn has_geodetic_inverse(&self) -> bool {
        self.geodetic_inverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geodetic_inverse(&mut self, v: GeodeticInverse) {
        self.geodetic_inverse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geodetic_inverse(&mut self) -> &mut GeodeticInverse {
        if self.geodetic_inverse.is_none() {
            self.geodetic_inverse.set_default();
        }
        self.geodetic_inverse.as_mut().unwrap()
    }

    // Take field
    pub fn take_geodetic_inverse(&mut self) -> GeodeticInverse {
        self.geodetic_inverse.take().unwrap_or_else(|| GeodeticInverse::new())
    }
}

impl ::protobuf::Message for GeometryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.envelope {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geodetic_inverse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spatial_relationship = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.measure = tmp;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeBool>(wire_type, is, &mut self.relate_map)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.envelope)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geodetic_inverse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.spatial_relationship != false {
            my_size += 2;
        }
        if self.measure != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeBool>(4, &self.relate_map);
        if let Some(ref v) = self.envelope.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.geodetic_inverse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.geometry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.spatial_relationship != false {
            os.write_bool(2, self.spatial_relationship)?;
        }
        if self.measure != 0. {
            os.write_double(3, self.measure)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeBool>(4, &self.relate_map, os)?;
        if let Some(ref v) = self.envelope.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.geodetic_inverse.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeometryResponse {
        GeometryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryData>>(
                    "geometry",
                    |m: &GeometryResponse| { &m.geometry },
                    |m: &mut GeometryResponse| { &mut m.geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spatial_relationship",
                    |m: &GeometryResponse| { &m.spatial_relationship },
                    |m: &mut GeometryResponse| { &mut m.spatial_relationship },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "measure",
                    |m: &GeometryResponse| { &m.measure },
                    |m: &mut GeometryResponse| { &mut m.measure },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeBool>(
                    "relate_map",
                    |m: &GeometryResponse| { &m.relate_map },
                    |m: &mut GeometryResponse| { &mut m.relate_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvelopeData>>(
                    "envelope",
                    |m: &GeometryResponse| { &m.envelope },
                    |m: &mut GeometryResponse| { &mut m.envelope },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeodeticInverse>>(
                    "geodetic_inverse",
                    |m: &GeometryResponse| { &m.geodetic_inverse },
                    |m: &mut GeometryResponse| { &mut m.geodetic_inverse },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeometryResponse>(
                    "GeometryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeometryResponse {
        static mut instance: ::protobuf::lazy::Lazy<GeometryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeometryResponse,
        };
        unsafe {
            instance.get(GeometryResponse::new)
        }
    }
}

impl ::protobuf::Clear for GeometryResponse {
    fn clear(&mut self) {
        self.geometry.clear();
        self.spatial_relationship = false;
        self.measure = 0.;
        self.relate_map.clear();
        self.envelope.clear();
        self.geodetic_inverse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeometryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeometryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FileRequestChunk {
    // message fields
    pub nested_request: ::protobuf::SingularPtrField<GeometryRequest>,
    pub result_encoding_type: Encoding,
    pub input_sr: ::protobuf::SingularPtrField<SpatialReferenceData>,
    pub result_sr: ::protobuf::SingularPtrField<SpatialReferenceData>,
    pub data: ::std::vec::Vec<u8>,
    pub size: i64,
    pub offset: i64,
    pub file_name: ::std::string::String,
    pub is_last_chunk: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileRequestChunk {
    fn default() -> &'a FileRequestChunk {
        <FileRequestChunk as ::protobuf::Message>::default_instance()
    }
}

impl FileRequestChunk {
    pub fn new() -> FileRequestChunk {
        ::std::default::Default::default()
    }

    // .epl.protobuf.GeometryRequest nested_request = 1;


    pub fn get_nested_request(&self) -> &GeometryRequest {
        self.nested_request.as_ref().unwrap_or_else(|| GeometryRequest::default_instance())
    }
    pub fn clear_nested_request(&mut self) {
        self.nested_request.clear();
    }

    pub fn has_nested_request(&self) -> bool {
        self.nested_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_request(&mut self, v: GeometryRequest) {
        self.nested_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nested_request(&mut self) -> &mut GeometryRequest {
        if self.nested_request.is_none() {
            self.nested_request.set_default();
        }
        self.nested_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_nested_request(&mut self) -> GeometryRequest {
        self.nested_request.take().unwrap_or_else(|| GeometryRequest::new())
    }

    // .epl.protobuf.Encoding result_encoding_type = 2;


    pub fn get_result_encoding_type(&self) -> Encoding {
        self.result_encoding_type
    }
    pub fn clear_result_encoding_type(&mut self) {
        self.result_encoding_type = Encoding::UNKNOWN_ENCODING;
    }

    // Param is passed by value, moved
    pub fn set_result_encoding_type(&mut self, v: Encoding) {
        self.result_encoding_type = v;
    }

    // .epl.protobuf.SpatialReferenceData input_sr = 3;


    pub fn get_input_sr(&self) -> &SpatialReferenceData {
        self.input_sr.as_ref().unwrap_or_else(|| SpatialReferenceData::default_instance())
    }
    pub fn clear_input_sr(&mut self) {
        self.input_sr.clear();
    }

    pub fn has_input_sr(&self) -> bool {
        self.input_sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_sr(&mut self, v: SpatialReferenceData) {
        self.input_sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_sr(&mut self) -> &mut SpatialReferenceData {
        if self.input_sr.is_none() {
            self.input_sr.set_default();
        }
        self.input_sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_sr(&mut self) -> SpatialReferenceData {
        self.input_sr.take().unwrap_or_else(|| SpatialReferenceData::new())
    }

    // .epl.protobuf.SpatialReferenceData result_sr = 5;


    pub fn get_result_sr(&self) -> &SpatialReferenceData {
        self.result_sr.as_ref().unwrap_or_else(|| SpatialReferenceData::default_instance())
    }
    pub fn clear_result_sr(&mut self) {
        self.result_sr.clear();
    }

    pub fn has_result_sr(&self) -> bool {
        self.result_sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_sr(&mut self, v: SpatialReferenceData) {
        self.result_sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_sr(&mut self) -> &mut SpatialReferenceData {
        if self.result_sr.is_none() {
            self.result_sr.set_default();
        }
        self.result_sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_sr(&mut self) -> SpatialReferenceData {
        self.result_sr.take().unwrap_or_else(|| SpatialReferenceData::new())
    }

    // bytes data = 6;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 size = 7;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // int64 offset = 8;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // string file_name = 9;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }

    // bool is_last_chunk = 10;


    pub fn get_is_last_chunk(&self) -> bool {
        self.is_last_chunk
    }
    pub fn clear_is_last_chunk(&mut self) {
        self.is_last_chunk = false;
    }

    // Param is passed by value, moved
    pub fn set_is_last_chunk(&mut self, v: bool) {
        self.is_last_chunk = v;
    }
}

impl ::protobuf::Message for FileRequestChunk {
    fn is_initialized(&self) -> bool {
        for v in &self.nested_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_sr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result_sr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nested_request)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result_encoding_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_sr)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result_sr)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_last_chunk = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nested_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.result_encoding_type != Encoding::UNKNOWN_ENCODING {
            my_size += ::protobuf::rt::enum_size(2, self.result_encoding_type);
        }
        if let Some(ref v) = self.input_sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result_sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.data);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(7, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(8, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.file_name);
        }
        if self.is_last_chunk != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nested_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.result_encoding_type != Encoding::UNKNOWN_ENCODING {
            os.write_enum(2, self.result_encoding_type.value())?;
        }
        if let Some(ref v) = self.input_sr.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result_sr.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(6, &self.data)?;
        }
        if self.size != 0 {
            os.write_int64(7, self.size)?;
        }
        if self.offset != 0 {
            os.write_int64(8, self.offset)?;
        }
        if !self.file_name.is_empty() {
            os.write_string(9, &self.file_name)?;
        }
        if self.is_last_chunk != false {
            os.write_bool(10, self.is_last_chunk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileRequestChunk {
        FileRequestChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeometryRequest>>(
                    "nested_request",
                    |m: &FileRequestChunk| { &m.nested_request },
                    |m: &mut FileRequestChunk| { &mut m.nested_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Encoding>>(
                    "result_encoding_type",
                    |m: &FileRequestChunk| { &m.result_encoding_type },
                    |m: &mut FileRequestChunk| { &mut m.result_encoding_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData>>(
                    "input_sr",
                    |m: &FileRequestChunk| { &m.input_sr },
                    |m: &mut FileRequestChunk| { &mut m.input_sr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialReferenceData>>(
                    "result_sr",
                    |m: &FileRequestChunk| { &m.result_sr },
                    |m: &mut FileRequestChunk| { &mut m.result_sr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &FileRequestChunk| { &m.data },
                    |m: &mut FileRequestChunk| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "size",
                    |m: &FileRequestChunk| { &m.size },
                    |m: &mut FileRequestChunk| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &FileRequestChunk| { &m.offset },
                    |m: &mut FileRequestChunk| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_name",
                    |m: &FileRequestChunk| { &m.file_name },
                    |m: &mut FileRequestChunk| { &mut m.file_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_last_chunk",
                    |m: &FileRequestChunk| { &m.is_last_chunk },
                    |m: &mut FileRequestChunk| { &mut m.is_last_chunk },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileRequestChunk>(
                    "FileRequestChunk",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileRequestChunk {
        static mut instance: ::protobuf::lazy::Lazy<FileRequestChunk> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileRequestChunk,
        };
        unsafe {
            instance.get(FileRequestChunk::new)
        }
    }
}

impl ::protobuf::Clear for FileRequestChunk {
    fn clear(&mut self) {
        self.nested_request.clear();
        self.result_encoding_type = Encoding::UNKNOWN_ENCODING;
        self.input_sr.clear();
        self.result_sr.clear();
        self.data.clear();
        self.size = 0;
        self.offset = 0;
        self.file_name.clear();
        self.is_last_chunk = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileRequestChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRequestChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum FileRequestChunk_FileType {
    SHAPEFILE = 0,
}

impl ::protobuf::ProtobufEnum for FileRequestChunk_FileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileRequestChunk_FileType> {
        match value {
            0 => ::std::option::Option::Some(FileRequestChunk_FileType::SHAPEFILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FileRequestChunk_FileType] = &[
            FileRequestChunk_FileType::SHAPEFILE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FileRequestChunk_FileType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FileRequestChunk_FileType {
}

impl ::std::default::Default for FileRequestChunk_FileType {
    fn default() -> Self {
        FileRequestChunk_FileType::SHAPEFILE
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRequestChunk_FileType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SimpleState {
    SIMPLE_UNKNOWN = 0,
    WEAK_SIMPLE = 1,
    STRONG_SIMPLE = 2,
    NON_SIMPLE = 3,
    STRUCTURE_FLAW = 4,
    DEGENERATE_SEGMENTS = 5,
    CLUSTERING = 6,
    CRACKING = 7,
    CROSS_OVER = 8,
    RING_ORIENTATION = 9,
}

impl ::protobuf::ProtobufEnum for SimpleState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SimpleState> {
        match value {
            0 => ::std::option::Option::Some(SimpleState::SIMPLE_UNKNOWN),
            1 => ::std::option::Option::Some(SimpleState::WEAK_SIMPLE),
            2 => ::std::option::Option::Some(SimpleState::STRONG_SIMPLE),
            3 => ::std::option::Option::Some(SimpleState::NON_SIMPLE),
            4 => ::std::option::Option::Some(SimpleState::STRUCTURE_FLAW),
            5 => ::std::option::Option::Some(SimpleState::DEGENERATE_SEGMENTS),
            6 => ::std::option::Option::Some(SimpleState::CLUSTERING),
            7 => ::std::option::Option::Some(SimpleState::CRACKING),
            8 => ::std::option::Option::Some(SimpleState::CROSS_OVER),
            9 => ::std::option::Option::Some(SimpleState::RING_ORIENTATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SimpleState] = &[
            SimpleState::SIMPLE_UNKNOWN,
            SimpleState::WEAK_SIMPLE,
            SimpleState::STRONG_SIMPLE,
            SimpleState::NON_SIMPLE,
            SimpleState::STRUCTURE_FLAW,
            SimpleState::DEGENERATE_SEGMENTS,
            SimpleState::CLUSTERING,
            SimpleState::CRACKING,
            SimpleState::CROSS_OVER,
            SimpleState::RING_ORIENTATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SimpleState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SimpleState {
}

impl ::std::default::Default for SimpleState {
    fn default() -> Self {
        SimpleState::SIMPLE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SimpleState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Encoding {
    UNKNOWN_ENCODING = 0,
    WKB = 1,
    WKT = 2,
    GEOJSON = 3,
    ESRI_SHAPE = 4,
    ENVELOPE = 5,
}

impl ::protobuf::ProtobufEnum for Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Encoding> {
        match value {
            0 => ::std::option::Option::Some(Encoding::UNKNOWN_ENCODING),
            1 => ::std::option::Option::Some(Encoding::WKB),
            2 => ::std::option::Option::Some(Encoding::WKT),
            3 => ::std::option::Option::Some(Encoding::GEOJSON),
            4 => ::std::option::Option::Some(Encoding::ESRI_SHAPE),
            5 => ::std::option::Option::Some(Encoding::ENVELOPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Encoding] = &[
            Encoding::UNKNOWN_ENCODING,
            Encoding::WKB,
            Encoding::WKT,
            Encoding::GEOJSON,
            Encoding::ESRI_SHAPE,
            Encoding::ENVELOPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Encoding", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Encoding {
}

impl ::std::default::Default for Encoding {
    fn default() -> Self {
        Encoding::UNKNOWN_ENCODING
    }
}

impl ::protobuf::reflect::ProtobufValue for Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum OperatorType {
    UNKNOWN_OPERATOR = 0,
    PROJECT = 1,
    EXPORT_TO_JSON = 2,
    IMPORT_FROM_JSON = 3,
    EXPORT_TO_ESRI_SHAPE = 4,
    IMPORT_FROM_ESRI_SHAPE = 5,
    UNION = 6,
    DIFFERENCE = 7,
    PROXIMITY_2D = 8,
    RELATE = 9,
    EQUALS = 10,
    DISJOINT = 11,
    INTERSECTS = 12,
    WITHIN = 13,
    CONTAINS = 14,
    CROSSES = 15,
    TOUCHES = 16,
    OVERLAPS = 17,
    BUFFER = 18,
    DISTANCE = 19,
    INTERSECTION = 20,
    CLIP = 21,
    CUT = 22,
    DENSIFY_BY_LENGTH = 23,
    GEODESIC_BUFFER = 26,
    GEODETIC_DENSIFY_BY_LENGTH = 27,
    GEODETIC_AREA = 30,
    SIMPLIFY = 31,
    SIMPLIFY_OGC = 32,
    OFFSET = 33,
    GENERALIZE = 34,
    GENERALIZE_BY_AREA = 35,
    EXPORT_TO_WKB = 36,
    IMPORT_FROM_WKB = 37,
    EXPORT_TO_WKT = 38,
    IMPORT_FROM_WKT = 39,
    IMPORT_FROM_GEOJSON = 40,
    EXPORT_TO_GEOJSON = 41,
    SYMMETRIC_DIFFERENCE = 42,
    CONVEX_HULL = 43,
    BOUNDARY = 44,
    RANDOM_POINTS = 45,
    ENCLOSING_CIRCLE = 46,
    AFFINE_TRANSFORM = 47,
    GEODETIC_LENGTH = 48,
    GEODETIC_INVERSE = 49,
}

impl ::protobuf::ProtobufEnum for OperatorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperatorType> {
        match value {
            0 => ::std::option::Option::Some(OperatorType::UNKNOWN_OPERATOR),
            1 => ::std::option::Option::Some(OperatorType::PROJECT),
            2 => ::std::option::Option::Some(OperatorType::EXPORT_TO_JSON),
            3 => ::std::option::Option::Some(OperatorType::IMPORT_FROM_JSON),
            4 => ::std::option::Option::Some(OperatorType::EXPORT_TO_ESRI_SHAPE),
            5 => ::std::option::Option::Some(OperatorType::IMPORT_FROM_ESRI_SHAPE),
            6 => ::std::option::Option::Some(OperatorType::UNION),
            7 => ::std::option::Option::Some(OperatorType::DIFFERENCE),
            8 => ::std::option::Option::Some(OperatorType::PROXIMITY_2D),
            9 => ::std::option::Option::Some(OperatorType::RELATE),
            10 => ::std::option::Option::Some(OperatorType::EQUALS),
            11 => ::std::option::Option::Some(OperatorType::DISJOINT),
            12 => ::std::option::Option::Some(OperatorType::INTERSECTS),
            13 => ::std::option::Option::Some(OperatorType::WITHIN),
            14 => ::std::option::Option::Some(OperatorType::CONTAINS),
            15 => ::std::option::Option::Some(OperatorType::CROSSES),
            16 => ::std::option::Option::Some(OperatorType::TOUCHES),
            17 => ::std::option::Option::Some(OperatorType::OVERLAPS),
            18 => ::std::option::Option::Some(OperatorType::BUFFER),
            19 => ::std::option::Option::Some(OperatorType::DISTANCE),
            20 => ::std::option::Option::Some(OperatorType::INTERSECTION),
            21 => ::std::option::Option::Some(OperatorType::CLIP),
            22 => ::std::option::Option::Some(OperatorType::CUT),
            23 => ::std::option::Option::Some(OperatorType::DENSIFY_BY_LENGTH),
            26 => ::std::option::Option::Some(OperatorType::GEODESIC_BUFFER),
            27 => ::std::option::Option::Some(OperatorType::GEODETIC_DENSIFY_BY_LENGTH),
            30 => ::std::option::Option::Some(OperatorType::GEODETIC_AREA),
            31 => ::std::option::Option::Some(OperatorType::SIMPLIFY),
            32 => ::std::option::Option::Some(OperatorType::SIMPLIFY_OGC),
            33 => ::std::option::Option::Some(OperatorType::OFFSET),
            34 => ::std::option::Option::Some(OperatorType::GENERALIZE),
            35 => ::std::option::Option::Some(OperatorType::GENERALIZE_BY_AREA),
            36 => ::std::option::Option::Some(OperatorType::EXPORT_TO_WKB),
            37 => ::std::option::Option::Some(OperatorType::IMPORT_FROM_WKB),
            38 => ::std::option::Option::Some(OperatorType::EXPORT_TO_WKT),
            39 => ::std::option::Option::Some(OperatorType::IMPORT_FROM_WKT),
            40 => ::std::option::Option::Some(OperatorType::IMPORT_FROM_GEOJSON),
            41 => ::std::option::Option::Some(OperatorType::EXPORT_TO_GEOJSON),
            42 => ::std::option::Option::Some(OperatorType::SYMMETRIC_DIFFERENCE),
            43 => ::std::option::Option::Some(OperatorType::CONVEX_HULL),
            44 => ::std::option::Option::Some(OperatorType::BOUNDARY),
            45 => ::std::option::Option::Some(OperatorType::RANDOM_POINTS),
            46 => ::std::option::Option::Some(OperatorType::ENCLOSING_CIRCLE),
            47 => ::std::option::Option::Some(OperatorType::AFFINE_TRANSFORM),
            48 => ::std::option::Option::Some(OperatorType::GEODETIC_LENGTH),
            49 => ::std::option::Option::Some(OperatorType::GEODETIC_INVERSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperatorType] = &[
            OperatorType::UNKNOWN_OPERATOR,
            OperatorType::PROJECT,
            OperatorType::EXPORT_TO_JSON,
            OperatorType::IMPORT_FROM_JSON,
            OperatorType::EXPORT_TO_ESRI_SHAPE,
            OperatorType::IMPORT_FROM_ESRI_SHAPE,
            OperatorType::UNION,
            OperatorType::DIFFERENCE,
            OperatorType::PROXIMITY_2D,
            OperatorType::RELATE,
            OperatorType::EQUALS,
            OperatorType::DISJOINT,
            OperatorType::INTERSECTS,
            OperatorType::WITHIN,
            OperatorType::CONTAINS,
            OperatorType::CROSSES,
            OperatorType::TOUCHES,
            OperatorType::OVERLAPS,
            OperatorType::BUFFER,
            OperatorType::DISTANCE,
            OperatorType::INTERSECTION,
            OperatorType::CLIP,
            OperatorType::CUT,
            OperatorType::DENSIFY_BY_LENGTH,
            OperatorType::GEODESIC_BUFFER,
            OperatorType::GEODETIC_DENSIFY_BY_LENGTH,
            OperatorType::GEODETIC_AREA,
            OperatorType::SIMPLIFY,
            OperatorType::SIMPLIFY_OGC,
            OperatorType::OFFSET,
            OperatorType::GENERALIZE,
            OperatorType::GENERALIZE_BY_AREA,
            OperatorType::EXPORT_TO_WKB,
            OperatorType::IMPORT_FROM_WKB,
            OperatorType::EXPORT_TO_WKT,
            OperatorType::IMPORT_FROM_WKT,
            OperatorType::IMPORT_FROM_GEOJSON,
            OperatorType::EXPORT_TO_GEOJSON,
            OperatorType::SYMMETRIC_DIFFERENCE,
            OperatorType::CONVEX_HULL,
            OperatorType::BOUNDARY,
            OperatorType::RANDOM_POINTS,
            OperatorType::ENCLOSING_CIRCLE,
            OperatorType::AFFINE_TRANSFORM,
            OperatorType::GEODETIC_LENGTH,
            OperatorType::GEODETIC_INVERSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperatorType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperatorType {
}

impl ::std::default::Default for OperatorType {
    fn default() -> Self {
        OperatorType::UNKNOWN_OPERATOR
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bepl/protobuf/geometry.proto\x12\x0cepl.protobuf\"\xd0\x02\n\x0cGeo\
    metryData\x12\x1f\n\x0bgeometry_id\x18\x01\x20\x01(\x04R\ngeometryId\x12\
    \x1d\n\nfeature_id\x18\x02\x20\x01(\tR\tfeatureId\x12\x10\n\x03wkt\x18\
    \x03\x20\x01(\tR\x03wkt\x12\x18\n\x07geojson\x18\x04\x20\x01(\tR\x07geoj\
    son\x12\x10\n\x03wkb\x18\x05\x20\x01(\x0cR\x03wkb\x12\x1d\n\nesri_shape\
    \x18\x06\x20\x01(\x0cR\tesriShape\x122\n\x02sr\x18\x07\x20\x01(\x0b2\".e\
    pl.protobuf.SpatialReferenceDataR\x02sr\x126\n\x08envelope\x18\r\x20\x01\
    (\x0b2\x1a.epl.protobuf.EnvelopeDataR\x08envelope\x121\n\x06simple\x18\
    \x0e\x20\x01(\x0e2\x19.epl.protobuf.SimpleStateR\x06simpleJ\x04\x08\x08\
    \x10\r\"\xc5\x02\n\x14SpatialReferenceData\x12\x12\n\x04wkid\x18\x01\x20\
    \x01(\x05R\x04wkid\x12\x14\n\x05proj4\x18\x02\x20\x01(\tR\x05proj4\x12A\
    \n\x06custom\x18\x03\x20\x01(\x0b2).epl.protobuf.SpatialReferenceData.Cu\
    stomR\x06custom\x12\x10\n\x03wkt\x18\x04\x20\x01(\tR\x03wkt\x12\x1b\n\te\
    sri_wkid\x18\x05\x20\x01(\x05R\x08esriWkid\x1av\n\x06Custom\x12\x13\n\
    \x05lon_0\x18\x01\x20\x01(\x01R\x04lon0\x12\x13\n\x05lat_0\x18\x02\x20\
    \x01(\x01R\x04lat0\x12B\n\x07cs_type\x18\x03\x20\x01(\x0e2).epl.protobuf\
    .SpatialReferenceData.CSTypeR\x06csType\"\x19\n\x06CSType\x12\x0f\n\x0bL\
    AMBERT_AZI\x10\0\"\xba\x01\n\x0cEnvelopeData\x12\x12\n\x04xmin\x18\x01\
    \x20\x01(\x01R\x04xmin\x12\x12\n\x04ymin\x18\x02\x20\x01(\x01R\x04ymin\
    \x12\x12\n\x04xmax\x18\x03\x20\x01(\x01R\x04xmax\x12\x12\n\x04ymax\x18\
    \x04\x20\x01(\x01R\x04ymax\x122\n\x02sr\x18\x05\x20\x01(\x0b2\".epl.prot\
    obuf.SpatialReferenceDataR\x02sr\x12\x12\n\x04zmin\x18\x06\x20\x01(\x01R\
    \x04zmin\x12\x12\n\x04zmax\x18\x07\x20\x01(\x01R\x04zmax\"\xeb\x19\n\x0f\
    GeometryRequest\x126\n\x08geometry\x18\x01\x20\x01(\x0b2\x1a.epl.protobu\
    f.GeometryDataR\x08geometry\x12?\n\rleft_geometry\x18\x02\x20\x01(\x0b2\
    \x1a.epl.protobuf.GeometryDataR\x0cleftGeometry\x12H\n\x10geometry_reque\
    st\x18\x03\x20\x01(\x0b2\x1d.epl.protobuf.GeometryRequestR\x0fgeometryRe\
    quest\x12Q\n\x15left_geometry_request\x18\x04\x20\x01(\x0b2\x1d.epl.prot\
    obuf.GeometryRequestR\x13leftGeometryRequest\x12A\n\x0eright_geometry\
    \x18\x05\x20\x01(\x0b2\x1a.epl.protobuf.GeometryDataR\rrightGeometry\x12\
    S\n\x16right_geometry_request\x18\x06\x20\x01(\x0b2\x1d.epl.protobuf.Geo\
    metryRequestR\x14rightGeometryRequest\x126\n\x08operator\x18\x07\x20\x01\
    (\x0e2\x1a.epl.protobuf.OperatorTypeR\x08operator\x12?\n\x0fresult_encod\
    ing\x18\x08\x20\x01(\x0e2\x16.epl.protobuf.EncodingR\x0eresultEncoding\
    \x12E\n\x0coperation_sr\x18\t\x20\x01(\x0b2\".epl.protobuf.SpatialRefere\
    nceDataR\x0boperationSr\x12?\n\tresult_sr\x18\n\x20\x01(\x0b2\".epl.prot\
    obuf.SpatialReferenceDataR\x08resultSr\x12O\n\rbuffer_params\x18\x0b\x20\
    \x01(\x0b2*.epl.protobuf.GeometryRequest.BufferParamsR\x0cbufferParams\
    \x12O\n\rconvex_params\x18\x0c\x20\x01(\x0b2*.epl.protobuf.GeometryReque\
    st.ConvexParamsR\x0cconvexParams\x12O\n\rrelate_params\x18\r\x20\x01(\
    \x0b2*.epl.protobuf.GeometryRequest.RelateParamsR\x0crelateParams\x12b\n\
    \x14random_points_params\x18\x0e\x20\x01(\x0b20.epl.protobuf.GeometryReq\
    uest.RandomPointsParamsR\x12randomPointsParams\x12[\n\x11generalize_para\
    ms\x18\x0f\x20\x01(\x0b2..epl.protobuf.GeometryRequest.GeneralizeParamsR\
    \x10generalizeParams\x12a\n\x13intersection_params\x18\x10\x20\x01(\x0b2\
    0.epl.protobuf.GeometryRequest.IntersectionParamsR\x12intersectionParams\
    \x12O\n\roffset_params\x18\x11\x20\x01(\x0b2*.epl.protobuf.GeometryReque\
    st.OffsetParamsR\x0coffsetParams\x12F\n\ncut_params\x18\x12\x20\x01(\x0b\
    2'.epl.protobuf.GeometryRequest.CutParamsR\tcutParams\x12I\n\x0bclip_par\
    ams\x18\x13\x20\x01(\x0b2(.epl.protobuf.GeometryRequest.ClipParamsR\ncli\
    pParams\x12R\n\x0edensify_params\x18\x14\x20\x01(\x0b2+.epl.protobuf.Geo\
    metryRequest.DensifyParamsR\rdensifyParams\x12U\n\x0fsimplify_params\x18\
    \x15\x20\x01(\x0b2,.epl.protobuf.GeometryRequest.SimplifyParamsR\x0esimp\
    lifyParams\x12o\n\x19generalize_by_area_params\x18\x16\x20\x01(\x0b24.ep\
    l.protobuf.GeometryRequest.GeneralizeByAreaParamsR\x16generalizeByAreaPa\
    rams\x12k\n\x17affine_transform_params\x18\x17\x20\x01(\x0b23.epl.protob\
    uf.GeometryRequest.AffineTransformParamsR\x15affineTransformParams\x1a\
    \xb0\x01\n\x0cBufferParams\x12\x1a\n\x08distance\x18\x01\x20\x01(\x01R\
    \x08distance\x12#\n\rmax_deviation\x18\x02\x20\x01(\x01R\x0cmaxDeviation\
    \x12!\n\x0cunion_result\x18\x03\x20\x01(\x08R\x0bunionResult\x12<\n\x1bm\
    ax_vertices_in_full_circle\x18\x04\x20\x01(\x05R\x17maxVerticesInFullCir\
    cle\x1a\xb8\x01\n\x14GeodeticBufferParams\x12\x1a\n\x08distance\x18\x01\
    \x20\x01(\x01R\x08distance\x12#\n\rmax_deviation\x18\x02\x20\x01(\x01R\
    \x0cmaxDeviation\x12!\n\x0cunion_result\x18\x03\x20\x01(\x08R\x0bunionRe\
    sult\x12<\n\x1bmax_vertices_in_full_circle\x18\x04\x20\x01(\x05R\x17maxV\
    erticesInFullCircle\x1a$\n\x0cConvexParams\x12\x14\n\x05merge\x18\x01\
    \x20\x01(\x08R\x05merge\x1a%\n\x0cRelateParams\x12\x15\n\x06de_9im\x18\
    \x01\x20\x01(\tR\x05de9im\x1aY\n\x12RandomPointsParams\x12/\n\x14points_\
    per_square_km\x18\x01\x20\x01(\x01R\x11pointsPerSquareKm\x12\x12\n\x04se\
    ed\x18\x02\x20\x01(\x03R\x04seed\x1af\n\x10GeneralizeParams\x12#\n\rmax_\
    deviation\x18\x01\x20\x01(\x01R\x0cmaxDeviation\x12-\n\x12remove_degener\
    ates\x18\x02\x20\x01(\x08R\x11removeDegenerates\x1a\x9c\x01\n\x16General\
    izeByAreaParams\x12+\n\x11percent_reduction\x18\x01\x20\x01(\x01R\x10per\
    centReduction\x12-\n\x12remove_degenerates\x18\x02\x20\x01(\x08R\x11remo\
    veDegenerates\x12&\n\x0fmax_point_count\x18\x03\x20\x01(\x05R\rmaxPointC\
    ount\x1a;\n\x12IntersectionParams\x12%\n\x0edimension_mask\x18\x01\x20\
    \x01(\x05R\rdimensionMask\x1a\x87\x02\n\x0cOffsetParams\x12\x1a\n\x08dis\
    tance\x18\x01\x20\x01(\x01R\x08distance\x12V\n\tjoin_type\x18\x02\x20\
    \x01(\x0e29.epl.protobuf.GeometryRequest.OffsetParams.OffsetJoinTypeR\
    \x08joinType\x12\x1f\n\x0bbevel_ratio\x18\x03\x20\x01(\x01R\nbevelRatio\
    \x12#\n\rflatten_error\x18\x04\x20\x01(\x01R\x0cflattenError\"=\n\x0eOff\
    setJoinType\x12\t\n\x05ROUND\x10\0\x12\t\n\x05BEVEL\x10\x01\x12\t\n\x05M\
    ITER\x10\x02\x12\n\n\x06SQUARE\x10\x03\x1a2\n\tCutParams\x12%\n\x0econsi\
    der_touch\x18\x01\x20\x01(\x08R\rconsiderTouch\x1aD\n\nClipParams\x126\n\
    \x08envelope\x18\x01\x20\x01(\x0b2\x1a.epl.protobuf.EnvelopeDataR\x08env\
    elope\x1a.\n\rDensifyParams\x12\x1d\n\nmax_length\x18\x01\x20\x01(\x01R\
    \tmaxLength\x1a&\n\x0eSimplifyParams\x12\x14\n\x05force\x18\x01\x20\x01(\
    \x08R\x05force\x1ao\n\x15AffineTransformParams\x12\x1a\n\x08geodetic\x18\
    \x02\x20\x01(\x08R\x08geodetic\x12\x19\n\x08x_offset\x18\x03\x20\x01(\
    \x01R\x07xOffset\x12\x19\n\x08y_offset\x18\x04\x20\x01(\x01R\x07yOffsetJ\
    \x04\x08\x01\x10\x02\"U\n\x0fGeodeticInverse\x12\x12\n\x04az12\x18\x01\
    \x20\x01(\x01R\x04az12\x12\x12\n\x04az21\x18\x02\x20\x01(\x01R\x04az21\
    \x12\x1a\n\x08distance\x18\x03\x20\x01(\x01R\x08distance\"\xa5\x03\n\x10\
    GeometryResponse\x126\n\x08geometry\x18\x01\x20\x01(\x0b2\x1a.epl.protob\
    uf.GeometryDataR\x08geometry\x121\n\x14spatial_relationship\x18\x02\x20\
    \x01(\x08R\x13spatialRelationship\x12\x18\n\x07measure\x18\x03\x20\x01(\
    \x01R\x07measure\x12L\n\nrelate_map\x18\x04\x20\x03(\x0b2-.epl.protobuf.\
    GeometryResponse.RelateMapEntryR\trelateMap\x126\n\x08envelope\x18\x05\
    \x20\x01(\x0b2\x1a.epl.protobuf.EnvelopeDataR\x08envelope\x12H\n\x10geod\
    etic_inverse\x18\x06\x20\x01(\x0b2\x1d.epl.protobuf.GeodeticInverseR\x0f\
    geodeticInverse\x1a<\n\x0eRelateMapEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x08R\x05value:\x02\
    8\x01\"\xbe\x03\n\x10FileRequestChunk\x12D\n\x0enested_request\x18\x01\
    \x20\x01(\x0b2\x1d.epl.protobuf.GeometryRequestR\rnestedRequest\x12H\n\
    \x14result_encoding_type\x18\x02\x20\x01(\x0e2\x16.epl.protobuf.Encoding\
    R\x12resultEncodingType\x12=\n\x08input_sr\x18\x03\x20\x01(\x0b2\".epl.p\
    rotobuf.SpatialReferenceDataR\x07inputSr\x12?\n\tresult_sr\x18\x05\x20\
    \x01(\x0b2\".epl.protobuf.SpatialReferenceDataR\x08resultSr\x12\x12\n\
    \x04data\x18\x06\x20\x01(\x0cR\x04data\x12\x12\n\x04size\x18\x07\x20\x01\
    (\x03R\x04size\x12\x16\n\x06offset\x18\x08\x20\x01(\x03R\x06offset\x12\
    \x1b\n\tfile_name\x18\t\x20\x01(\tR\x08fileName\x12\"\n\ris_last_chunk\
    \x18\n\x20\x01(\x08R\x0bisLastChunk\"\x19\n\x08FileType\x12\r\n\tSHAPEFI\
    LE\x10\0*\xc6\x01\n\x0bSimpleState\x12\x12\n\x0eSIMPLE_UNKNOWN\x10\0\x12\
    \x0f\n\x0bWEAK_SIMPLE\x10\x01\x12\x11\n\rSTRONG_SIMPLE\x10\x02\x12\x0e\n\
    \nNON_SIMPLE\x10\x03\x12\x12\n\x0eSTRUCTURE_FLAW\x10\x04\x12\x17\n\x13DE\
    GENERATE_SEGMENTS\x10\x05\x12\x0e\n\nCLUSTERING\x10\x06\x12\x0c\n\x08CRA\
    CKING\x10\x07\x12\x0e\n\nCROSS_OVER\x10\x08\x12\x14\n\x10RING_ORIENTATIO\
    N\x10\t*]\n\x08Encoding\x12\x14\n\x10UNKNOWN_ENCODING\x10\0\x12\x07\n\
    \x03WKB\x10\x01\x12\x07\n\x03WKT\x10\x02\x12\x0b\n\x07GEOJSON\x10\x03\
    \x12\x0e\n\nESRI_SHAPE\x10\x04\x12\x0c\n\x08ENVELOPE\x10\x05*\xcb\x06\n\
    \x0cOperatorType\x12\x14\n\x10UNKNOWN_OPERATOR\x10\0\x12\x0b\n\x07PROJEC\
    T\x10\x01\x12\x12\n\x0eEXPORT_TO_JSON\x10\x02\x12\x14\n\x10IMPORT_FROM_J\
    SON\x10\x03\x12\x18\n\x14EXPORT_TO_ESRI_SHAPE\x10\x04\x12\x1a\n\x16IMPOR\
    T_FROM_ESRI_SHAPE\x10\x05\x12\t\n\x05UNION\x10\x06\x12\x0e\n\nDIFFERENCE\
    \x10\x07\x12\x10\n\x0cPROXIMITY_2D\x10\x08\x12\n\n\x06RELATE\x10\t\x12\n\
    \n\x06EQUALS\x10\n\x12\x0c\n\x08DISJOINT\x10\x0b\x12\x0e\n\nINTERSECTS\
    \x10\x0c\x12\n\n\x06WITHIN\x10\r\x12\x0c\n\x08CONTAINS\x10\x0e\x12\x0b\n\
    \x07CROSSES\x10\x0f\x12\x0b\n\x07TOUCHES\x10\x10\x12\x0c\n\x08OVERLAPS\
    \x10\x11\x12\n\n\x06BUFFER\x10\x12\x12\x0c\n\x08DISTANCE\x10\x13\x12\x10\
    \n\x0cINTERSECTION\x10\x14\x12\x08\n\x04CLIP\x10\x15\x12\x07\n\x03CUT\
    \x10\x16\x12\x15\n\x11DENSIFY_BY_LENGTH\x10\x17\x12\x13\n\x0fGEODESIC_BU\
    FFER\x10\x1a\x12\x1e\n\x1aGEODETIC_DENSIFY_BY_LENGTH\x10\x1b\x12\x11\n\r\
    GEODETIC_AREA\x10\x1e\x12\x0c\n\x08SIMPLIFY\x10\x1f\x12\x10\n\x0cSIMPLIF\
    Y_OGC\x10\x20\x12\n\n\x06OFFSET\x10!\x12\x0e\n\nGENERALIZE\x10\"\x12\x16\
    \n\x12GENERALIZE_BY_AREA\x10#\x12\x11\n\rEXPORT_TO_WKB\x10$\x12\x13\n\
    \x0fIMPORT_FROM_WKB\x10%\x12\x11\n\rEXPORT_TO_WKT\x10&\x12\x13\n\x0fIMPO\
    RT_FROM_WKT\x10'\x12\x17\n\x13IMPORT_FROM_GEOJSON\x10(\x12\x15\n\x11EXPO\
    RT_TO_GEOJSON\x10)\x12\x18\n\x14SYMMETRIC_DIFFERENCE\x10*\x12\x0f\n\x0bC\
    ONVEX_HULL\x10+\x12\x0c\n\x08BOUNDARY\x10,\x12\x11\n\rRANDOM_POINTS\x10-\
    \x12\x14\n\x10ENCLOSING_CIRCLE\x10.\x12\x14\n\x10AFFINE_TRANSFORM\x10/\
    \x12\x13\n\x0fGEODETIC_LENGTH\x100\x12\x14\n\x10GEODETIC_INVERSE\x101BW\
    \n\x10com.epl.protobufB\rGeometryProtoP\x01Z+github.com/geo-grpc/api/gol\
    ang/epl/protobuf\xa2\x02\x04GMPBb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
