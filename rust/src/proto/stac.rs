// This file is generated by rust-protobuf 2.10.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `epl/protobuf/stac.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StacItem {
    // message fields
    pub id: ::std::string::String,
    pub geometry: ::protobuf::SingularPtrField<super::geometry::GeometryData>,
    pub bbox: ::protobuf::SingularPtrField<super::geometry::EnvelopeData>,
    pub properties: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub assets: ::std::collections::HashMap<::std::string::String, Asset>,
    pub datetime: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub title: ::std::string::String,
    pub collection: ::std::string::String,
    pub observed: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub processed: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub eo: ::protobuf::SingularPtrField<Eo>,
    pub sar: ::protobuf::SingularPtrField<Sar>,
    pub landsat: ::protobuf::SingularPtrField<Landsat>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StacItem {
    fn default() -> &'a StacItem {
        <StacItem as ::protobuf::Message>::default_instance()
    }
}

impl StacItem {
    pub fn new() -> StacItem {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .epl.protobuf.GeometryData geometry = 3;


    pub fn get_geometry(&self) -> &super::geometry::GeometryData {
        self.geometry.as_ref().unwrap_or_else(|| super::geometry::GeometryData::default_instance())
    }
    pub fn clear_geometry(&mut self) {
        self.geometry.clear();
    }

    pub fn has_geometry(&self) -> bool {
        self.geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: super::geometry::GeometryData) {
        self.geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry(&mut self) -> &mut super::geometry::GeometryData {
        if self.geometry.is_none() {
            self.geometry.set_default();
        }
        self.geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry(&mut self) -> super::geometry::GeometryData {
        self.geometry.take().unwrap_or_else(|| super::geometry::GeometryData::new())
    }

    // .epl.protobuf.EnvelopeData bbox = 4;


    pub fn get_bbox(&self) -> &super::geometry::EnvelopeData {
        self.bbox.as_ref().unwrap_or_else(|| super::geometry::EnvelopeData::default_instance())
    }
    pub fn clear_bbox(&mut self) {
        self.bbox.clear();
    }

    pub fn has_bbox(&self) -> bool {
        self.bbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bbox(&mut self, v: super::geometry::EnvelopeData) {
        self.bbox = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bbox(&mut self) -> &mut super::geometry::EnvelopeData {
        if self.bbox.is_none() {
            self.bbox.set_default();
        }
        self.bbox.as_mut().unwrap()
    }

    // Take field
    pub fn take_bbox(&mut self) -> super::geometry::EnvelopeData {
        self.bbox.take().unwrap_or_else(|| super::geometry::EnvelopeData::new())
    }

    // .google.protobuf.Any properties = 5;


    pub fn get_properties(&self) -> &::protobuf::well_known_types::Any {
        self.properties.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::well_known_types::Any) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::well_known_types::Any {
        self.properties.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // repeated .epl.protobuf.StacItem.AssetsEntry assets = 7;


    pub fn get_assets(&self) -> &::std::collections::HashMap<::std::string::String, Asset> {
        &self.assets
    }
    pub fn clear_assets(&mut self) {
        self.assets.clear();
    }

    // Param is passed by value, moved
    pub fn set_assets(&mut self, v: ::std::collections::HashMap<::std::string::String, Asset>) {
        self.assets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Asset> {
        &mut self.assets
    }

    // Take field
    pub fn take_assets(&mut self) -> ::std::collections::HashMap<::std::string::String, Asset> {
        ::std::mem::replace(&mut self.assets, ::std::collections::HashMap::new())
    }

    // .google.protobuf.Timestamp datetime = 8;


    pub fn get_datetime(&self) -> &::protobuf::well_known_types::Timestamp {
        self.datetime.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_datetime(&mut self) {
        self.datetime.clear();
    }

    pub fn has_datetime(&self) -> bool {
        self.datetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datetime(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.datetime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datetime(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.datetime.is_none() {
            self.datetime.set_default();
        }
        self.datetime.as_mut().unwrap()
    }

    // Take field
    pub fn take_datetime(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.datetime.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string title = 9;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string collection = 10;


    pub fn get_collection(&self) -> &str {
        &self.collection
    }
    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp observed = 11;


    pub fn get_observed(&self) -> &::protobuf::well_known_types::Timestamp {
        self.observed.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_observed(&mut self) {
        self.observed.clear();
    }

    pub fn has_observed(&self) -> bool {
        self.observed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observed(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.observed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observed(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.observed.is_none() {
            self.observed.set_default();
        }
        self.observed.as_mut().unwrap()
    }

    // Take field
    pub fn take_observed(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.observed.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Duration duration = 18;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Timestamp processed = 12;


    pub fn get_processed(&self) -> &::protobuf::well_known_types::Timestamp {
        self.processed.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_processed(&mut self) {
        self.processed.clear();
    }

    pub fn has_processed(&self) -> bool {
        self.processed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processed(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.processed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_processed(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.processed.is_none() {
            self.processed.set_default();
        }
        self.processed.as_mut().unwrap()
    }

    // Take field
    pub fn take_processed(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.processed.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated = 13;


    pub fn get_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .epl.protobuf.Eo eo = 14;


    pub fn get_eo(&self) -> &Eo {
        self.eo.as_ref().unwrap_or_else(|| Eo::default_instance())
    }
    pub fn clear_eo(&mut self) {
        self.eo.clear();
    }

    pub fn has_eo(&self) -> bool {
        self.eo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eo(&mut self, v: Eo) {
        self.eo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eo(&mut self) -> &mut Eo {
        if self.eo.is_none() {
            self.eo.set_default();
        }
        self.eo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eo(&mut self) -> Eo {
        self.eo.take().unwrap_or_else(|| Eo::new())
    }

    // .epl.protobuf.Sar sar = 15;


    pub fn get_sar(&self) -> &Sar {
        self.sar.as_ref().unwrap_or_else(|| Sar::default_instance())
    }
    pub fn clear_sar(&mut self) {
        self.sar.clear();
    }

    pub fn has_sar(&self) -> bool {
        self.sar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sar(&mut self, v: Sar) {
        self.sar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sar(&mut self) -> &mut Sar {
        if self.sar.is_none() {
            self.sar.set_default();
        }
        self.sar.as_mut().unwrap()
    }

    // Take field
    pub fn take_sar(&mut self) -> Sar {
        self.sar.take().unwrap_or_else(|| Sar::new())
    }

    // .epl.protobuf.Landsat landsat = 17;


    pub fn get_landsat(&self) -> &Landsat {
        self.landsat.as_ref().unwrap_or_else(|| Landsat::default_instance())
    }
    pub fn clear_landsat(&mut self) {
        self.landsat.clear();
    }

    pub fn has_landsat(&self) -> bool {
        self.landsat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_landsat(&mut self, v: Landsat) {
        self.landsat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_landsat(&mut self) -> &mut Landsat {
        if self.landsat.is_none() {
            self.landsat.set_default();
        }
        self.landsat.as_mut().unwrap()
    }

    // Take field
    pub fn take_landsat(&mut self) -> Landsat {
        self.landsat.take().unwrap_or_else(|| Landsat::new())
    }
}

impl ::protobuf::Message for StacItem {
    fn is_initialized(&self) -> bool {
        for v in &self.geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.datetime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.observed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.processed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.landsat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bbox)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Asset>>(wire_type, is, &mut self.assets)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datetime)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.observed)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.processed)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eo)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sar)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.landsat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Asset>>(7, &self.assets);
        if let Some(ref v) = self.datetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.title);
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.collection);
        }
        if let Some(ref v) = self.observed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.processed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.eo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.landsat.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.geometry.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bbox.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Asset>>(7, &self.assets, os)?;
        if let Some(ref v) = self.datetime.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.title.is_empty() {
            os.write_string(9, &self.title)?;
        }
        if !self.collection.is_empty() {
            os.write_string(10, &self.collection)?;
        }
        if let Some(ref v) = self.observed.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.processed.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.eo.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sar.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.landsat.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StacItem {
        StacItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &StacItem| { &m.id },
                    |m: &mut StacItem| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::GeometryData>>(
                    "geometry",
                    |m: &StacItem| { &m.geometry },
                    |m: &mut StacItem| { &mut m.geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::EnvelopeData>>(
                    "bbox",
                    |m: &StacItem| { &m.bbox },
                    |m: &mut StacItem| { &mut m.bbox },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "properties",
                    |m: &StacItem| { &m.properties },
                    |m: &mut StacItem| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Asset>>(
                    "assets",
                    |m: &StacItem| { &m.assets },
                    |m: &mut StacItem| { &mut m.assets },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "datetime",
                    |m: &StacItem| { &m.datetime },
                    |m: &mut StacItem| { &mut m.datetime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &StacItem| { &m.title },
                    |m: &mut StacItem| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &StacItem| { &m.collection },
                    |m: &mut StacItem| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "observed",
                    |m: &StacItem| { &m.observed },
                    |m: &mut StacItem| { &mut m.observed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "duration",
                    |m: &StacItem| { &m.duration },
                    |m: &mut StacItem| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "processed",
                    |m: &StacItem| { &m.processed },
                    |m: &mut StacItem| { &mut m.processed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "updated",
                    |m: &StacItem| { &m.updated },
                    |m: &mut StacItem| { &mut m.updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Eo>>(
                    "eo",
                    |m: &StacItem| { &m.eo },
                    |m: &mut StacItem| { &mut m.eo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sar>>(
                    "sar",
                    |m: &StacItem| { &m.sar },
                    |m: &mut StacItem| { &mut m.sar },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Landsat>>(
                    "landsat",
                    |m: &StacItem| { &m.landsat },
                    |m: &mut StacItem| { &mut m.landsat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StacItem>(
                    "StacItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StacItem {
        static mut instance: ::protobuf::lazy::Lazy<StacItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StacItem,
        };
        unsafe {
            instance.get(StacItem::new)
        }
    }
}

impl ::protobuf::Clear for StacItem {
    fn clear(&mut self) {
        self.id.clear();
        self.geometry.clear();
        self.bbox.clear();
        self.properties.clear();
        self.assets.clear();
        self.datetime.clear();
        self.title.clear();
        self.collection.clear();
        self.observed.clear();
        self.duration.clear();
        self.processed.clear();
        self.updated.clear();
        self.eo.clear();
        self.sar.clear();
        self.landsat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StacItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StacItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StacRequest {
    // message fields
    pub id: ::std::string::String,
    pub geometry: ::protobuf::SingularPtrField<super::geometry::GeometryData>,
    pub bbox: ::protobuf::SingularPtrField<super::geometry::EnvelopeData>,
    pub geometry_request: ::protobuf::SingularPtrField<super::geometry::GeometryRequest>,
    pub properties: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub datetime: ::protobuf::SingularPtrField<super::query::TimestampField>,
    pub observed: ::protobuf::SingularPtrField<super::query::TimestampField>,
    pub processed: ::protobuf::SingularPtrField<super::query::TimestampField>,
    pub updated: ::protobuf::SingularPtrField<super::query::TimestampField>,
    pub eo: ::protobuf::SingularPtrField<EoRequest>,
    pub limit: u32,
    pub offset: u64,
    pub landsat: ::protobuf::SingularPtrField<LandsatRequest>,
    pub collection: ::std::string::String,
    pub id_complex: ::protobuf::SingularPtrField<super::query::StringField>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StacRequest {
    fn default() -> &'a StacRequest {
        <StacRequest as ::protobuf::Message>::default_instance()
    }
}

impl StacRequest {
    pub fn new() -> StacRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .epl.protobuf.GeometryData geometry = 2;


    pub fn get_geometry(&self) -> &super::geometry::GeometryData {
        self.geometry.as_ref().unwrap_or_else(|| super::geometry::GeometryData::default_instance())
    }
    pub fn clear_geometry(&mut self) {
        self.geometry.clear();
    }

    pub fn has_geometry(&self) -> bool {
        self.geometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry(&mut self, v: super::geometry::GeometryData) {
        self.geometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry(&mut self) -> &mut super::geometry::GeometryData {
        if self.geometry.is_none() {
            self.geometry.set_default();
        }
        self.geometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry(&mut self) -> super::geometry::GeometryData {
        self.geometry.take().unwrap_or_else(|| super::geometry::GeometryData::new())
    }

    // .epl.protobuf.EnvelopeData bbox = 3;


    pub fn get_bbox(&self) -> &super::geometry::EnvelopeData {
        self.bbox.as_ref().unwrap_or_else(|| super::geometry::EnvelopeData::default_instance())
    }
    pub fn clear_bbox(&mut self) {
        self.bbox.clear();
    }

    pub fn has_bbox(&self) -> bool {
        self.bbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bbox(&mut self, v: super::geometry::EnvelopeData) {
        self.bbox = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bbox(&mut self) -> &mut super::geometry::EnvelopeData {
        if self.bbox.is_none() {
            self.bbox.set_default();
        }
        self.bbox.as_mut().unwrap()
    }

    // Take field
    pub fn take_bbox(&mut self) -> super::geometry::EnvelopeData {
        self.bbox.take().unwrap_or_else(|| super::geometry::EnvelopeData::new())
    }

    // .epl.protobuf.GeometryRequest geometry_request = 4;


    pub fn get_geometry_request(&self) -> &super::geometry::GeometryRequest {
        self.geometry_request.as_ref().unwrap_or_else(|| super::geometry::GeometryRequest::default_instance())
    }
    pub fn clear_geometry_request(&mut self) {
        self.geometry_request.clear();
    }

    pub fn has_geometry_request(&self) -> bool {
        self.geometry_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geometry_request(&mut self, v: super::geometry::GeometryRequest) {
        self.geometry_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geometry_request(&mut self) -> &mut super::geometry::GeometryRequest {
        if self.geometry_request.is_none() {
            self.geometry_request.set_default();
        }
        self.geometry_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_geometry_request(&mut self) -> super::geometry::GeometryRequest {
        self.geometry_request.take().unwrap_or_else(|| super::geometry::GeometryRequest::new())
    }

    // .google.protobuf.Any properties = 5;


    pub fn get_properties(&self) -> &::protobuf::well_known_types::Any {
        self.properties.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::well_known_types::Any) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::well_known_types::Any {
        self.properties.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .epl.protobuf.TimestampField datetime = 6;


    pub fn get_datetime(&self) -> &super::query::TimestampField {
        self.datetime.as_ref().unwrap_or_else(|| super::query::TimestampField::default_instance())
    }
    pub fn clear_datetime(&mut self) {
        self.datetime.clear();
    }

    pub fn has_datetime(&self) -> bool {
        self.datetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datetime(&mut self, v: super::query::TimestampField) {
        self.datetime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datetime(&mut self) -> &mut super::query::TimestampField {
        if self.datetime.is_none() {
            self.datetime.set_default();
        }
        self.datetime.as_mut().unwrap()
    }

    // Take field
    pub fn take_datetime(&mut self) -> super::query::TimestampField {
        self.datetime.take().unwrap_or_else(|| super::query::TimestampField::new())
    }

    // .epl.protobuf.TimestampField observed = 7;


    pub fn get_observed(&self) -> &super::query::TimestampField {
        self.observed.as_ref().unwrap_or_else(|| super::query::TimestampField::default_instance())
    }
    pub fn clear_observed(&mut self) {
        self.observed.clear();
    }

    pub fn has_observed(&self) -> bool {
        self.observed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observed(&mut self, v: super::query::TimestampField) {
        self.observed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observed(&mut self) -> &mut super::query::TimestampField {
        if self.observed.is_none() {
            self.observed.set_default();
        }
        self.observed.as_mut().unwrap()
    }

    // Take field
    pub fn take_observed(&mut self) -> super::query::TimestampField {
        self.observed.take().unwrap_or_else(|| super::query::TimestampField::new())
    }

    // .epl.protobuf.TimestampField processed = 8;


    pub fn get_processed(&self) -> &super::query::TimestampField {
        self.processed.as_ref().unwrap_or_else(|| super::query::TimestampField::default_instance())
    }
    pub fn clear_processed(&mut self) {
        self.processed.clear();
    }

    pub fn has_processed(&self) -> bool {
        self.processed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processed(&mut self, v: super::query::TimestampField) {
        self.processed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_processed(&mut self) -> &mut super::query::TimestampField {
        if self.processed.is_none() {
            self.processed.set_default();
        }
        self.processed.as_mut().unwrap()
    }

    // Take field
    pub fn take_processed(&mut self) -> super::query::TimestampField {
        self.processed.take().unwrap_or_else(|| super::query::TimestampField::new())
    }

    // .epl.protobuf.TimestampField updated = 9;


    pub fn get_updated(&self) -> &super::query::TimestampField {
        self.updated.as_ref().unwrap_or_else(|| super::query::TimestampField::default_instance())
    }
    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: super::query::TimestampField) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut super::query::TimestampField {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> super::query::TimestampField {
        self.updated.take().unwrap_or_else(|| super::query::TimestampField::new())
    }

    // .epl.protobuf.EoRequest eo = 10;


    pub fn get_eo(&self) -> &EoRequest {
        self.eo.as_ref().unwrap_or_else(|| EoRequest::default_instance())
    }
    pub fn clear_eo(&mut self) {
        self.eo.clear();
    }

    pub fn has_eo(&self) -> bool {
        self.eo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eo(&mut self, v: EoRequest) {
        self.eo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eo(&mut self) -> &mut EoRequest {
        if self.eo.is_none() {
            self.eo.set_default();
        }
        self.eo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eo(&mut self) -> EoRequest {
        self.eo.take().unwrap_or_else(|| EoRequest::new())
    }

    // uint32 limit = 11;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // uint64 offset = 12;


    pub fn get_offset(&self) -> u64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = v;
    }

    // .epl.protobuf.LandsatRequest landsat = 13;


    pub fn get_landsat(&self) -> &LandsatRequest {
        self.landsat.as_ref().unwrap_or_else(|| LandsatRequest::default_instance())
    }
    pub fn clear_landsat(&mut self) {
        self.landsat.clear();
    }

    pub fn has_landsat(&self) -> bool {
        self.landsat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_landsat(&mut self, v: LandsatRequest) {
        self.landsat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_landsat(&mut self) -> &mut LandsatRequest {
        if self.landsat.is_none() {
            self.landsat.set_default();
        }
        self.landsat.as_mut().unwrap()
    }

    // Take field
    pub fn take_landsat(&mut self) -> LandsatRequest {
        self.landsat.take().unwrap_or_else(|| LandsatRequest::new())
    }

    // string collection = 14;


    pub fn get_collection(&self) -> &str {
        &self.collection
    }
    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    // .epl.protobuf.StringField id_complex = 15;


    pub fn get_id_complex(&self) -> &super::query::StringField {
        self.id_complex.as_ref().unwrap_or_else(|| super::query::StringField::default_instance())
    }
    pub fn clear_id_complex(&mut self) {
        self.id_complex.clear();
    }

    pub fn has_id_complex(&self) -> bool {
        self.id_complex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_complex(&mut self, v: super::query::StringField) {
        self.id_complex = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_complex(&mut self) -> &mut super::query::StringField {
        if self.id_complex.is_none() {
            self.id_complex.set_default();
        }
        self.id_complex.as_mut().unwrap()
    }

    // Take field
    pub fn take_id_complex(&mut self) -> super::query::StringField {
        self.id_complex.take().unwrap_or_else(|| super::query::StringField::new())
    }
}

impl ::protobuf::Message for StacRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.geometry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geometry_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.datetime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.observed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.processed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.landsat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id_complex {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bbox)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geometry_request)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datetime)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.observed)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.processed)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eo)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.landsat)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id_complex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.geometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.geometry_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.datetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.observed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.processed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.eo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(11, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(12, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.landsat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.collection);
        }
        if let Some(ref v) = self.id_complex.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.geometry.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bbox.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.geometry_request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.datetime.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.observed.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.processed.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.eo.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.limit != 0 {
            os.write_uint32(11, self.limit)?;
        }
        if self.offset != 0 {
            os.write_uint64(12, self.offset)?;
        }
        if let Some(ref v) = self.landsat.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.collection.is_empty() {
            os.write_string(14, &self.collection)?;
        }
        if let Some(ref v) = self.id_complex.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StacRequest {
        StacRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &StacRequest| { &m.id },
                    |m: &mut StacRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::GeometryData>>(
                    "geometry",
                    |m: &StacRequest| { &m.geometry },
                    |m: &mut StacRequest| { &mut m.geometry },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::EnvelopeData>>(
                    "bbox",
                    |m: &StacRequest| { &m.bbox },
                    |m: &mut StacRequest| { &mut m.bbox },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::GeometryRequest>>(
                    "geometry_request",
                    |m: &StacRequest| { &m.geometry_request },
                    |m: &mut StacRequest| { &mut m.geometry_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "properties",
                    |m: &StacRequest| { &m.properties },
                    |m: &mut StacRequest| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::TimestampField>>(
                    "datetime",
                    |m: &StacRequest| { &m.datetime },
                    |m: &mut StacRequest| { &mut m.datetime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::TimestampField>>(
                    "observed",
                    |m: &StacRequest| { &m.observed },
                    |m: &mut StacRequest| { &mut m.observed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::TimestampField>>(
                    "processed",
                    |m: &StacRequest| { &m.processed },
                    |m: &mut StacRequest| { &mut m.processed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::TimestampField>>(
                    "updated",
                    |m: &StacRequest| { &m.updated },
                    |m: &mut StacRequest| { &mut m.updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EoRequest>>(
                    "eo",
                    |m: &StacRequest| { &m.eo },
                    |m: &mut StacRequest| { &mut m.eo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "limit",
                    |m: &StacRequest| { &m.limit },
                    |m: &mut StacRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    |m: &StacRequest| { &m.offset },
                    |m: &mut StacRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LandsatRequest>>(
                    "landsat",
                    |m: &StacRequest| { &m.landsat },
                    |m: &mut StacRequest| { &mut m.landsat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &StacRequest| { &m.collection },
                    |m: &mut StacRequest| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::StringField>>(
                    "id_complex",
                    |m: &StacRequest| { &m.id_complex },
                    |m: &mut StacRequest| { &mut m.id_complex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StacRequest>(
                    "StacRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StacRequest {
        static mut instance: ::protobuf::lazy::Lazy<StacRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StacRequest,
        };
        unsafe {
            instance.get(StacRequest::new)
        }
    }
}

impl ::protobuf::Clear for StacRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.geometry.clear();
        self.bbox.clear();
        self.geometry_request.clear();
        self.properties.clear();
        self.datetime.clear();
        self.observed.clear();
        self.processed.clear();
        self.updated.clear();
        self.eo.clear();
        self.limit = 0;
        self.offset = 0;
        self.landsat.clear();
        self.collection.clear();
        self.id_complex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StacRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StacRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Asset {
    // message fields
    pub href: ::std::string::String,
    pub field_type: ::std::string::String,
    pub eo_bands: Eo_Band,
    pub asset_type: AssetType,
    pub cloud_platform: CloudPlatform,
    pub bucket_manager: ::std::string::String,
    pub bucket_region: ::std::string::String,
    pub bucket: ::std::string::String,
    pub object_path: ::std::string::String,
    pub requester_pays: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset {
    fn default() -> &'a Asset {
        <Asset as ::protobuf::Message>::default_instance()
    }
}

impl Asset {
    pub fn new() -> Asset {
        ::std::default::Default::default()
    }

    // string href = 1;


    pub fn get_href(&self) -> &str {
        &self.href
    }
    pub fn clear_href(&mut self) {
        self.href.clear();
    }

    // Param is passed by value, moved
    pub fn set_href(&mut self, v: ::std::string::String) {
        self.href = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_href(&mut self) -> &mut ::std::string::String {
        &mut self.href
    }

    // Take field
    pub fn take_href(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.href, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // .epl.protobuf.Eo.Band eo_bands = 3;


    pub fn get_eo_bands(&self) -> Eo_Band {
        self.eo_bands
    }
    pub fn clear_eo_bands(&mut self) {
        self.eo_bands = Eo_Band::UNKNOWN_BAND;
    }

    // Param is passed by value, moved
    pub fn set_eo_bands(&mut self, v: Eo_Band) {
        self.eo_bands = v;
    }

    // .epl.protobuf.AssetType asset_type = 4;


    pub fn get_asset_type(&self) -> AssetType {
        self.asset_type
    }
    pub fn clear_asset_type(&mut self) {
        self.asset_type = AssetType::UNKNOWN_ASSET;
    }

    // Param is passed by value, moved
    pub fn set_asset_type(&mut self, v: AssetType) {
        self.asset_type = v;
    }

    // .epl.protobuf.CloudPlatform cloud_platform = 5;


    pub fn get_cloud_platform(&self) -> CloudPlatform {
        self.cloud_platform
    }
    pub fn clear_cloud_platform(&mut self) {
        self.cloud_platform = CloudPlatform::UNKNOWN_CLOUD_PLATFORM;
    }

    // Param is passed by value, moved
    pub fn set_cloud_platform(&mut self, v: CloudPlatform) {
        self.cloud_platform = v;
    }

    // string bucket_manager = 6;


    pub fn get_bucket_manager(&self) -> &str {
        &self.bucket_manager
    }
    pub fn clear_bucket_manager(&mut self) {
        self.bucket_manager.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket_manager(&mut self, v: ::std::string::String) {
        self.bucket_manager = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket_manager(&mut self) -> &mut ::std::string::String {
        &mut self.bucket_manager
    }

    // Take field
    pub fn take_bucket_manager(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket_manager, ::std::string::String::new())
    }

    // string bucket_region = 7;


    pub fn get_bucket_region(&self) -> &str {
        &self.bucket_region
    }
    pub fn clear_bucket_region(&mut self) {
        self.bucket_region.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket_region(&mut self, v: ::std::string::String) {
        self.bucket_region = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket_region(&mut self) -> &mut ::std::string::String {
        &mut self.bucket_region
    }

    // Take field
    pub fn take_bucket_region(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket_region, ::std::string::String::new())
    }

    // string bucket = 8;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object_path = 9;


    pub fn get_object_path(&self) -> &str {
        &self.object_path
    }
    pub fn clear_object_path(&mut self) {
        self.object_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_path(&mut self, v: ::std::string::String) {
        self.object_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_path(&mut self) -> &mut ::std::string::String {
        &mut self.object_path
    }

    // Take field
    pub fn take_object_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_path, ::std::string::String::new())
    }

    // bool requester_pays = 10;


    pub fn get_requester_pays(&self) -> bool {
        self.requester_pays
    }
    pub fn clear_requester_pays(&mut self) {
        self.requester_pays = false;
    }

    // Param is passed by value, moved
    pub fn set_requester_pays(&mut self, v: bool) {
        self.requester_pays = v;
    }
}

impl ::protobuf::Message for Asset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.href)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.eo_bands, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.asset_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cloud_platform, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket_manager)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket_region)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_path)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requester_pays = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.href.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.href);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if self.eo_bands != Eo_Band::UNKNOWN_BAND {
            my_size += ::protobuf::rt::enum_size(3, self.eo_bands);
        }
        if self.asset_type != AssetType::UNKNOWN_ASSET {
            my_size += ::protobuf::rt::enum_size(4, self.asset_type);
        }
        if self.cloud_platform != CloudPlatform::UNKNOWN_CLOUD_PLATFORM {
            my_size += ::protobuf::rt::enum_size(5, self.cloud_platform);
        }
        if !self.bucket_manager.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.bucket_manager);
        }
        if !self.bucket_region.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.bucket_region);
        }
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.bucket);
        }
        if !self.object_path.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.object_path);
        }
        if self.requester_pays != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.href.is_empty() {
            os.write_string(1, &self.href)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if self.eo_bands != Eo_Band::UNKNOWN_BAND {
            os.write_enum(3, self.eo_bands.value())?;
        }
        if self.asset_type != AssetType::UNKNOWN_ASSET {
            os.write_enum(4, self.asset_type.value())?;
        }
        if self.cloud_platform != CloudPlatform::UNKNOWN_CLOUD_PLATFORM {
            os.write_enum(5, self.cloud_platform.value())?;
        }
        if !self.bucket_manager.is_empty() {
            os.write_string(6, &self.bucket_manager)?;
        }
        if !self.bucket_region.is_empty() {
            os.write_string(7, &self.bucket_region)?;
        }
        if !self.bucket.is_empty() {
            os.write_string(8, &self.bucket)?;
        }
        if !self.object_path.is_empty() {
            os.write_string(9, &self.object_path)?;
        }
        if self.requester_pays != false {
            os.write_bool(10, self.requester_pays)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset {
        Asset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "href",
                    |m: &Asset| { &m.href },
                    |m: &mut Asset| { &mut m.href },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Asset| { &m.field_type },
                    |m: &mut Asset| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Band>>(
                    "eo_bands",
                    |m: &Asset| { &m.eo_bands },
                    |m: &mut Asset| { &mut m.eo_bands },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AssetType>>(
                    "asset_type",
                    |m: &Asset| { &m.asset_type },
                    |m: &mut Asset| { &mut m.asset_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CloudPlatform>>(
                    "cloud_platform",
                    |m: &Asset| { &m.cloud_platform },
                    |m: &mut Asset| { &mut m.cloud_platform },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bucket_manager",
                    |m: &Asset| { &m.bucket_manager },
                    |m: &mut Asset| { &mut m.bucket_manager },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bucket_region",
                    |m: &Asset| { &m.bucket_region },
                    |m: &mut Asset| { &mut m.bucket_region },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bucket",
                    |m: &Asset| { &m.bucket },
                    |m: &mut Asset| { &mut m.bucket },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "object_path",
                    |m: &Asset| { &m.object_path },
                    |m: &mut Asset| { &mut m.object_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "requester_pays",
                    |m: &Asset| { &m.requester_pays },
                    |m: &mut Asset| { &mut m.requester_pays },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset>(
                    "Asset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset {
        static mut instance: ::protobuf::lazy::Lazy<Asset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset,
        };
        unsafe {
            instance.get(Asset::new)
        }
    }
}

impl ::protobuf::Clear for Asset {
    fn clear(&mut self) {
        self.href.clear();
        self.field_type.clear();
        self.eo_bands = Eo_Band::UNKNOWN_BAND;
        self.asset_type = AssetType::UNKNOWN_ASSET;
        self.cloud_platform = CloudPlatform::UNKNOWN_CLOUD_PLATFORM;
        self.bucket_manager.clear();
        self.bucket_region.clear();
        self.bucket.clear();
        self.object_path.clear();
        self.requester_pays = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DatetimeRange {
    // message fields
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatetimeRange {
    fn default() -> &'a DatetimeRange {
        <DatetimeRange as ::protobuf::Message>::default_instance()
    }
}

impl DatetimeRange {
    pub fn new() -> DatetimeRange {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp start = 1;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end = 2;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for DatetimeRange {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatetimeRange {
        DatetimeRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "start",
                    |m: &DatetimeRange| { &m.start },
                    |m: &mut DatetimeRange| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "end",
                    |m: &DatetimeRange| { &m.end },
                    |m: &mut DatetimeRange| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatetimeRange>(
                    "DatetimeRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatetimeRange {
        static mut instance: ::protobuf::lazy::Lazy<DatetimeRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatetimeRange,
        };
        unsafe {
            instance.get(DatetimeRange::new)
        }
    }
}

impl ::protobuf::Clear for DatetimeRange {
    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatetimeRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatetimeRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StacDbResponse {
    // message fields
    pub status: ::std::string::String,
    pub status_code: i32,
    pub data_id: ::std::string::String,
    pub count: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StacDbResponse {
    fn default() -> &'a StacDbResponse {
        <StacDbResponse as ::protobuf::Message>::default_instance()
    }
}

impl StacDbResponse {
    pub fn new() -> StacDbResponse {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // int32 status_code = 2;


    pub fn get_status_code(&self) -> i32 {
        self.status_code
    }
    pub fn clear_status_code(&mut self) {
        self.status_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = v;
    }

    // string data_id = 3;


    pub fn get_data_id(&self) -> &str {
        &self.data_id
    }
    pub fn clear_data_id(&mut self) {
        self.data_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_id(&mut self, v: ::std::string::String) {
        self.data_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_id(&mut self) -> &mut ::std::string::String {
        &mut self.data_id
    }

    // Take field
    pub fn take_data_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data_id, ::std::string::String::new())
    }

    // uint64 count = 4;


    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }
}

impl ::protobuf::Message for StacDbResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status_code = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        if self.status_code != 0 {
            my_size += ::protobuf::rt::value_size(2, self.status_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.data_id);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        if self.status_code != 0 {
            os.write_int32(2, self.status_code)?;
        }
        if !self.data_id.is_empty() {
            os.write_string(3, &self.data_id)?;
        }
        if self.count != 0 {
            os.write_uint64(4, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StacDbResponse {
        StacDbResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    |m: &StacDbResponse| { &m.status },
                    |m: &mut StacDbResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status_code",
                    |m: &StacDbResponse| { &m.status_code },
                    |m: &mut StacDbResponse| { &mut m.status_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data_id",
                    |m: &StacDbResponse| { &m.data_id },
                    |m: &mut StacDbResponse| { &mut m.data_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "count",
                    |m: &StacDbResponse| { &m.count },
                    |m: &mut StacDbResponse| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StacDbResponse>(
                    "StacDbResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StacDbResponse {
        static mut instance: ::protobuf::lazy::Lazy<StacDbResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StacDbResponse,
        };
        unsafe {
            instance.get(StacDbResponse::new)
        }
    }
}

impl ::protobuf::Clear for StacDbResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.status_code = 0;
        self.data_id.clear();
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StacDbResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StacDbResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Sar {
    // message fields
    pub platform: Sar_Platform,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sar {
    fn default() -> &'a Sar {
        <Sar as ::protobuf::Message>::default_instance()
    }
}

impl Sar {
    pub fn new() -> Sar {
        ::std::default::Default::default()
    }

    // .epl.protobuf.Sar.Platform platform = 1;


    pub fn get_platform(&self) -> Sar_Platform {
        self.platform
    }
    pub fn clear_platform(&mut self) {
        self.platform = Sar_Platform::UNKNOWN_PLATFORM;
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: Sar_Platform) {
        self.platform = v;
    }
}

impl ::protobuf::Message for Sar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.platform, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.platform != Sar_Platform::UNKNOWN_PLATFORM {
            my_size += ::protobuf::rt::enum_size(1, self.platform);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.platform != Sar_Platform::UNKNOWN_PLATFORM {
            os.write_enum(1, self.platform.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sar {
        Sar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Sar_Platform>>(
                    "platform",
                    |m: &Sar| { &m.platform },
                    |m: &mut Sar| { &mut m.platform },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sar>(
                    "Sar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Sar {
        static mut instance: ::protobuf::lazy::Lazy<Sar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Sar,
        };
        unsafe {
            instance.get(Sar::new)
        }
    }
}

impl ::protobuf::Clear for Sar {
    fn clear(&mut self) {
        self.platform = Sar_Platform::UNKNOWN_PLATFORM;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sar {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Sar_Platform {
    UNKNOWN_PLATFORM = 0,
    ENVISAT = 1,
    SENTINEL_1A = 2,
}

impl ::protobuf::ProtobufEnum for Sar_Platform {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Sar_Platform> {
        match value {
            0 => ::std::option::Option::Some(Sar_Platform::UNKNOWN_PLATFORM),
            1 => ::std::option::Option::Some(Sar_Platform::ENVISAT),
            2 => ::std::option::Option::Some(Sar_Platform::SENTINEL_1A),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Sar_Platform] = &[
            Sar_Platform::UNKNOWN_PLATFORM,
            Sar_Platform::ENVISAT,
            Sar_Platform::SENTINEL_1A,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Sar_Platform", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Sar_Platform {
}

impl ::std::default::Default for Sar_Platform {
    fn default() -> Self {
        Sar_Platform::UNKNOWN_PLATFORM
    }
}

impl ::protobuf::reflect::ProtobufValue for Sar_Platform {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Sar_Instrument {
    UNKNOWN_INSTRUMENT = 0,
}

impl ::protobuf::ProtobufEnum for Sar_Instrument {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Sar_Instrument> {
        match value {
            0 => ::std::option::Option::Some(Sar_Instrument::UNKNOWN_INSTRUMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Sar_Instrument] = &[
            Sar_Instrument::UNKNOWN_INSTRUMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Sar_Instrument", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Sar_Instrument {
}

impl ::std::default::Default for Sar_Instrument {
    fn default() -> Self {
        Sar_Instrument::UNKNOWN_INSTRUMENT
    }
}

impl ::protobuf::reflect::ProtobufValue for Sar_Instrument {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Eo {
    // message fields
    pub epsg: u32,
    pub platform: Eo_Platform,
    pub instrument: Eo_Instrument,
    pub constellation: Eo_Constellation,
    pub sun_azimuth: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub sun_elevation: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub gsd: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub off_nadir: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub azimuth: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub cloud_cover: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub bands: Eo_Band,
    pub sr: ::protobuf::SingularPtrField<super::geometry::SpatialReferenceData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Eo {
    fn default() -> &'a Eo {
        <Eo as ::protobuf::Message>::default_instance()
    }
}

impl Eo {
    pub fn new() -> Eo {
        ::std::default::Default::default()
    }

    // uint32 epsg = 1;


    pub fn get_epsg(&self) -> u32 {
        self.epsg
    }
    pub fn clear_epsg(&mut self) {
        self.epsg = 0;
    }

    // Param is passed by value, moved
    pub fn set_epsg(&mut self, v: u32) {
        self.epsg = v;
    }

    // .epl.protobuf.Eo.Platform platform = 2;


    pub fn get_platform(&self) -> Eo_Platform {
        self.platform
    }
    pub fn clear_platform(&mut self) {
        self.platform = Eo_Platform::UNKNOWN_PLATFORM;
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: Eo_Platform) {
        self.platform = v;
    }

    // .epl.protobuf.Eo.Instrument instrument = 3;


    pub fn get_instrument(&self) -> Eo_Instrument {
        self.instrument
    }
    pub fn clear_instrument(&mut self) {
        self.instrument = Eo_Instrument::UNKNOWN_INSTRUMENT;
    }

    // Param is passed by value, moved
    pub fn set_instrument(&mut self, v: Eo_Instrument) {
        self.instrument = v;
    }

    // .epl.protobuf.Eo.Constellation constellation = 4;


    pub fn get_constellation(&self) -> Eo_Constellation {
        self.constellation
    }
    pub fn clear_constellation(&mut self) {
        self.constellation = Eo_Constellation::UNKNOWN_CONSTELLATION;
    }

    // Param is passed by value, moved
    pub fn set_constellation(&mut self, v: Eo_Constellation) {
        self.constellation = v;
    }

    // .google.protobuf.FloatValue sun_azimuth = 5;


    pub fn get_sun_azimuth(&self) -> &::protobuf::well_known_types::FloatValue {
        self.sun_azimuth.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_sun_azimuth(&mut self) {
        self.sun_azimuth.clear();
    }

    pub fn has_sun_azimuth(&self) -> bool {
        self.sun_azimuth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sun_azimuth(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.sun_azimuth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sun_azimuth(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.sun_azimuth.is_none() {
            self.sun_azimuth.set_default();
        }
        self.sun_azimuth.as_mut().unwrap()
    }

    // Take field
    pub fn take_sun_azimuth(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.sun_azimuth.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue sun_elevation = 6;


    pub fn get_sun_elevation(&self) -> &::protobuf::well_known_types::FloatValue {
        self.sun_elevation.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_sun_elevation(&mut self) {
        self.sun_elevation.clear();
    }

    pub fn has_sun_elevation(&self) -> bool {
        self.sun_elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sun_elevation(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.sun_elevation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sun_elevation(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.sun_elevation.is_none() {
            self.sun_elevation.set_default();
        }
        self.sun_elevation.as_mut().unwrap()
    }

    // Take field
    pub fn take_sun_elevation(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.sun_elevation.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue gsd = 7;


    pub fn get_gsd(&self) -> &::protobuf::well_known_types::FloatValue {
        self.gsd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_gsd(&mut self) {
        self.gsd.clear();
    }

    pub fn has_gsd(&self) -> bool {
        self.gsd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gsd(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.gsd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gsd(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.gsd.is_none() {
            self.gsd.set_default();
        }
        self.gsd.as_mut().unwrap()
    }

    // Take field
    pub fn take_gsd(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.gsd.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue off_nadir = 8;


    pub fn get_off_nadir(&self) -> &::protobuf::well_known_types::FloatValue {
        self.off_nadir.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_off_nadir(&mut self) {
        self.off_nadir.clear();
    }

    pub fn has_off_nadir(&self) -> bool {
        self.off_nadir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_off_nadir(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.off_nadir = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_off_nadir(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.off_nadir.is_none() {
            self.off_nadir.set_default();
        }
        self.off_nadir.as_mut().unwrap()
    }

    // Take field
    pub fn take_off_nadir(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.off_nadir.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue azimuth = 9;


    pub fn get_azimuth(&self) -> &::protobuf::well_known_types::FloatValue {
        self.azimuth.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_azimuth(&mut self) {
        self.azimuth.clear();
    }

    pub fn has_azimuth(&self) -> bool {
        self.azimuth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azimuth(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.azimuth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azimuth(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.azimuth.is_none() {
            self.azimuth.set_default();
        }
        self.azimuth.as_mut().unwrap()
    }

    // Take field
    pub fn take_azimuth(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.azimuth.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue cloud_cover = 10;


    pub fn get_cloud_cover(&self) -> &::protobuf::well_known_types::FloatValue {
        self.cloud_cover.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_cloud_cover(&mut self) {
        self.cloud_cover.clear();
    }

    pub fn has_cloud_cover(&self) -> bool {
        self.cloud_cover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_cover(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.cloud_cover = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud_cover(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.cloud_cover.is_none() {
            self.cloud_cover.set_default();
        }
        self.cloud_cover.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud_cover(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.cloud_cover.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .epl.protobuf.Eo.Band bands = 11;


    pub fn get_bands(&self) -> Eo_Band {
        self.bands
    }
    pub fn clear_bands(&mut self) {
        self.bands = Eo_Band::UNKNOWN_BAND;
    }

    // Param is passed by value, moved
    pub fn set_bands(&mut self, v: Eo_Band) {
        self.bands = v;
    }

    // .epl.protobuf.SpatialReferenceData sr = 12;


    pub fn get_sr(&self) -> &super::geometry::SpatialReferenceData {
        self.sr.as_ref().unwrap_or_else(|| super::geometry::SpatialReferenceData::default_instance())
    }
    pub fn clear_sr(&mut self) {
        self.sr.clear();
    }

    pub fn has_sr(&self) -> bool {
        self.sr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sr(&mut self, v: super::geometry::SpatialReferenceData) {
        self.sr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sr(&mut self) -> &mut super::geometry::SpatialReferenceData {
        if self.sr.is_none() {
            self.sr.set_default();
        }
        self.sr.as_mut().unwrap()
    }

    // Take field
    pub fn take_sr(&mut self) -> super::geometry::SpatialReferenceData {
        self.sr.take().unwrap_or_else(|| super::geometry::SpatialReferenceData::new())
    }
}

impl ::protobuf::Message for Eo {
    fn is_initialized(&self) -> bool {
        for v in &self.sun_azimuth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sun_elevation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gsd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.off_nadir {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azimuth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloud_cover {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.epsg = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.platform, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.instrument, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.constellation, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sun_azimuth)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sun_elevation)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gsd)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.off_nadir)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azimuth)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud_cover)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.bands, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epsg != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epsg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.platform != Eo_Platform::UNKNOWN_PLATFORM {
            my_size += ::protobuf::rt::enum_size(2, self.platform);
        }
        if self.instrument != Eo_Instrument::UNKNOWN_INSTRUMENT {
            my_size += ::protobuf::rt::enum_size(3, self.instrument);
        }
        if self.constellation != Eo_Constellation::UNKNOWN_CONSTELLATION {
            my_size += ::protobuf::rt::enum_size(4, self.constellation);
        }
        if let Some(ref v) = self.sun_azimuth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sun_elevation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gsd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.off_nadir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azimuth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloud_cover.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bands != Eo_Band::UNKNOWN_BAND {
            my_size += ::protobuf::rt::enum_size(11, self.bands);
        }
        if let Some(ref v) = self.sr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epsg != 0 {
            os.write_uint32(1, self.epsg)?;
        }
        if self.platform != Eo_Platform::UNKNOWN_PLATFORM {
            os.write_enum(2, self.platform.value())?;
        }
        if self.instrument != Eo_Instrument::UNKNOWN_INSTRUMENT {
            os.write_enum(3, self.instrument.value())?;
        }
        if self.constellation != Eo_Constellation::UNKNOWN_CONSTELLATION {
            os.write_enum(4, self.constellation.value())?;
        }
        if let Some(ref v) = self.sun_azimuth.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sun_elevation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gsd.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.off_nadir.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azimuth.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloud_cover.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bands != Eo_Band::UNKNOWN_BAND {
            os.write_enum(11, self.bands.value())?;
        }
        if let Some(ref v) = self.sr.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Eo {
        Eo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "epsg",
                    |m: &Eo| { &m.epsg },
                    |m: &mut Eo| { &mut m.epsg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Platform>>(
                    "platform",
                    |m: &Eo| { &m.platform },
                    |m: &mut Eo| { &mut m.platform },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Instrument>>(
                    "instrument",
                    |m: &Eo| { &m.instrument },
                    |m: &mut Eo| { &mut m.instrument },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Constellation>>(
                    "constellation",
                    |m: &Eo| { &m.constellation },
                    |m: &mut Eo| { &mut m.constellation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "sun_azimuth",
                    |m: &Eo| { &m.sun_azimuth },
                    |m: &mut Eo| { &mut m.sun_azimuth },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "sun_elevation",
                    |m: &Eo| { &m.sun_elevation },
                    |m: &mut Eo| { &mut m.sun_elevation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "gsd",
                    |m: &Eo| { &m.gsd },
                    |m: &mut Eo| { &mut m.gsd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "off_nadir",
                    |m: &Eo| { &m.off_nadir },
                    |m: &mut Eo| { &mut m.off_nadir },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "azimuth",
                    |m: &Eo| { &m.azimuth },
                    |m: &mut Eo| { &mut m.azimuth },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "cloud_cover",
                    |m: &Eo| { &m.cloud_cover },
                    |m: &mut Eo| { &mut m.cloud_cover },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Band>>(
                    "bands",
                    |m: &Eo| { &m.bands },
                    |m: &mut Eo| { &mut m.bands },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::SpatialReferenceData>>(
                    "sr",
                    |m: &Eo| { &m.sr },
                    |m: &mut Eo| { &mut m.sr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Eo>(
                    "Eo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Eo {
        static mut instance: ::protobuf::lazy::Lazy<Eo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Eo,
        };
        unsafe {
            instance.get(Eo::new)
        }
    }
}

impl ::protobuf::Clear for Eo {
    fn clear(&mut self) {
        self.epsg = 0;
        self.platform = Eo_Platform::UNKNOWN_PLATFORM;
        self.instrument = Eo_Instrument::UNKNOWN_INSTRUMENT;
        self.constellation = Eo_Constellation::UNKNOWN_CONSTELLATION;
        self.sun_azimuth.clear();
        self.sun_elevation.clear();
        self.gsd.clear();
        self.off_nadir.clear();
        self.azimuth.clear();
        self.cloud_cover.clear();
        self.bands = Eo_Band::UNKNOWN_BAND;
        self.sr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Eo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Eo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Eo_Platform {
    UNKNOWN_PLATFORM = 0,
    LANDSAT_1 = 2,
    LANDSAT_2 = 4,
    LANDSAT_3 = 8,
    LANDSAT_123 = 14,
    LANDSAT_4 = 16,
    LANDSAT_5 = 32,
    LANDSAT_45 = 48,
    LANDSAT_7 = 64,
    LANDSAT_8 = 128,
    SWIFT_2 = 256,
}

impl ::protobuf::ProtobufEnum for Eo_Platform {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Eo_Platform> {
        match value {
            0 => ::std::option::Option::Some(Eo_Platform::UNKNOWN_PLATFORM),
            2 => ::std::option::Option::Some(Eo_Platform::LANDSAT_1),
            4 => ::std::option::Option::Some(Eo_Platform::LANDSAT_2),
            8 => ::std::option::Option::Some(Eo_Platform::LANDSAT_3),
            14 => ::std::option::Option::Some(Eo_Platform::LANDSAT_123),
            16 => ::std::option::Option::Some(Eo_Platform::LANDSAT_4),
            32 => ::std::option::Option::Some(Eo_Platform::LANDSAT_5),
            48 => ::std::option::Option::Some(Eo_Platform::LANDSAT_45),
            64 => ::std::option::Option::Some(Eo_Platform::LANDSAT_7),
            128 => ::std::option::Option::Some(Eo_Platform::LANDSAT_8),
            256 => ::std::option::Option::Some(Eo_Platform::SWIFT_2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Eo_Platform] = &[
            Eo_Platform::UNKNOWN_PLATFORM,
            Eo_Platform::LANDSAT_1,
            Eo_Platform::LANDSAT_2,
            Eo_Platform::LANDSAT_3,
            Eo_Platform::LANDSAT_123,
            Eo_Platform::LANDSAT_4,
            Eo_Platform::LANDSAT_5,
            Eo_Platform::LANDSAT_45,
            Eo_Platform::LANDSAT_7,
            Eo_Platform::LANDSAT_8,
            Eo_Platform::SWIFT_2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Eo_Platform", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Eo_Platform {
}

impl ::std::default::Default for Eo_Platform {
    fn default() -> Self {
        Eo_Platform::UNKNOWN_PLATFORM
    }
}

impl ::protobuf::reflect::ProtobufValue for Eo_Platform {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Eo_Instrument {
    UNKNOWN_INSTRUMENT = 0,
    OLI = 2,
    TIRS = 4,
    OLI_TIRS = 6,
    POM_1 = 8,
    TM = 16,
    ETM = 32,
    MSS = 64,
}

impl ::protobuf::ProtobufEnum for Eo_Instrument {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Eo_Instrument> {
        match value {
            0 => ::std::option::Option::Some(Eo_Instrument::UNKNOWN_INSTRUMENT),
            2 => ::std::option::Option::Some(Eo_Instrument::OLI),
            4 => ::std::option::Option::Some(Eo_Instrument::TIRS),
            6 => ::std::option::Option::Some(Eo_Instrument::OLI_TIRS),
            8 => ::std::option::Option::Some(Eo_Instrument::POM_1),
            16 => ::std::option::Option::Some(Eo_Instrument::TM),
            32 => ::std::option::Option::Some(Eo_Instrument::ETM),
            64 => ::std::option::Option::Some(Eo_Instrument::MSS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Eo_Instrument] = &[
            Eo_Instrument::UNKNOWN_INSTRUMENT,
            Eo_Instrument::OLI,
            Eo_Instrument::TIRS,
            Eo_Instrument::OLI_TIRS,
            Eo_Instrument::POM_1,
            Eo_Instrument::TM,
            Eo_Instrument::ETM,
            Eo_Instrument::MSS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Eo_Instrument", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Eo_Instrument {
}

impl ::std::default::Default for Eo_Instrument {
    fn default() -> Self {
        Eo_Instrument::UNKNOWN_INSTRUMENT
    }
}

impl ::protobuf::reflect::ProtobufValue for Eo_Instrument {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Eo_Constellation {
    UNKNOWN_CONSTELLATION = 0,
    LANDSAT = 2,
    NAIP = 4,
    PNOA = 8,
    SWIFT = 16,
}

impl ::protobuf::ProtobufEnum for Eo_Constellation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Eo_Constellation> {
        match value {
            0 => ::std::option::Option::Some(Eo_Constellation::UNKNOWN_CONSTELLATION),
            2 => ::std::option::Option::Some(Eo_Constellation::LANDSAT),
            4 => ::std::option::Option::Some(Eo_Constellation::NAIP),
            8 => ::std::option::Option::Some(Eo_Constellation::PNOA),
            16 => ::std::option::Option::Some(Eo_Constellation::SWIFT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Eo_Constellation] = &[
            Eo_Constellation::UNKNOWN_CONSTELLATION,
            Eo_Constellation::LANDSAT,
            Eo_Constellation::NAIP,
            Eo_Constellation::PNOA,
            Eo_Constellation::SWIFT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Eo_Constellation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Eo_Constellation {
}

impl ::std::default::Default for Eo_Constellation {
    fn default() -> Self {
        Eo_Constellation::UNKNOWN_CONSTELLATION
    }
}

impl ::protobuf::reflect::ProtobufValue for Eo_Constellation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Eo_Band {
    UNKNOWN_BAND = 0,
    COASTAL = 2,
    BLUE = 4,
    GREEN = 8,
    RED = 16,
    RGB = 28,
    NIR = 32,
    NIR_2 = 33,
    RGBIR = 60,
    SWIR_1 = 64,
    SWIR_2 = 128,
    PAN = 256,
    CIRRUS = 512,
    LWIR_1 = 1024,
    LWIR_2 = 2048,
}

impl ::protobuf::ProtobufEnum for Eo_Band {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Eo_Band> {
        match value {
            0 => ::std::option::Option::Some(Eo_Band::UNKNOWN_BAND),
            2 => ::std::option::Option::Some(Eo_Band::COASTAL),
            4 => ::std::option::Option::Some(Eo_Band::BLUE),
            8 => ::std::option::Option::Some(Eo_Band::GREEN),
            16 => ::std::option::Option::Some(Eo_Band::RED),
            28 => ::std::option::Option::Some(Eo_Band::RGB),
            32 => ::std::option::Option::Some(Eo_Band::NIR),
            33 => ::std::option::Option::Some(Eo_Band::NIR_2),
            60 => ::std::option::Option::Some(Eo_Band::RGBIR),
            64 => ::std::option::Option::Some(Eo_Band::SWIR_1),
            128 => ::std::option::Option::Some(Eo_Band::SWIR_2),
            256 => ::std::option::Option::Some(Eo_Band::PAN),
            512 => ::std::option::Option::Some(Eo_Band::CIRRUS),
            1024 => ::std::option::Option::Some(Eo_Band::LWIR_1),
            2048 => ::std::option::Option::Some(Eo_Band::LWIR_2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Eo_Band] = &[
            Eo_Band::UNKNOWN_BAND,
            Eo_Band::COASTAL,
            Eo_Band::BLUE,
            Eo_Band::GREEN,
            Eo_Band::RED,
            Eo_Band::RGB,
            Eo_Band::NIR,
            Eo_Band::NIR_2,
            Eo_Band::RGBIR,
            Eo_Band::SWIR_1,
            Eo_Band::SWIR_2,
            Eo_Band::PAN,
            Eo_Band::CIRRUS,
            Eo_Band::LWIR_1,
            Eo_Band::LWIR_2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Eo_Band", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Eo_Band {
}

impl ::std::default::Default for Eo_Band {
    fn default() -> Self {
        Eo_Band::UNKNOWN_BAND
    }
}

impl ::protobuf::reflect::ProtobufValue for Eo_Band {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EoRequest {
    // message fields
    pub epsg: i32,
    pub platform: Eo_Platform,
    pub instrument: Eo_Instrument,
    pub constellation: Eo_Constellation,
    pub sun_azimuth: ::protobuf::SingularPtrField<super::query::FloatField>,
    pub sun_elevation: ::protobuf::SingularPtrField<super::query::FloatField>,
    pub gsd: ::protobuf::SingularPtrField<super::query::FloatField>,
    pub off_nadir: ::protobuf::SingularPtrField<super::query::FloatField>,
    pub azimuth: ::protobuf::SingularPtrField<super::query::FloatField>,
    pub cloud_cover: ::protobuf::SingularPtrField<super::query::FloatField>,
    pub bands: Eo_Band,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EoRequest {
    fn default() -> &'a EoRequest {
        <EoRequest as ::protobuf::Message>::default_instance()
    }
}

impl EoRequest {
    pub fn new() -> EoRequest {
        ::std::default::Default::default()
    }

    // int32 epsg = 1;


    pub fn get_epsg(&self) -> i32 {
        self.epsg
    }
    pub fn clear_epsg(&mut self) {
        self.epsg = 0;
    }

    // Param is passed by value, moved
    pub fn set_epsg(&mut self, v: i32) {
        self.epsg = v;
    }

    // .epl.protobuf.Eo.Platform platform = 2;


    pub fn get_platform(&self) -> Eo_Platform {
        self.platform
    }
    pub fn clear_platform(&mut self) {
        self.platform = Eo_Platform::UNKNOWN_PLATFORM;
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: Eo_Platform) {
        self.platform = v;
    }

    // .epl.protobuf.Eo.Instrument instrument = 3;


    pub fn get_instrument(&self) -> Eo_Instrument {
        self.instrument
    }
    pub fn clear_instrument(&mut self) {
        self.instrument = Eo_Instrument::UNKNOWN_INSTRUMENT;
    }

    // Param is passed by value, moved
    pub fn set_instrument(&mut self, v: Eo_Instrument) {
        self.instrument = v;
    }

    // .epl.protobuf.Eo.Constellation constellation = 4;


    pub fn get_constellation(&self) -> Eo_Constellation {
        self.constellation
    }
    pub fn clear_constellation(&mut self) {
        self.constellation = Eo_Constellation::UNKNOWN_CONSTELLATION;
    }

    // Param is passed by value, moved
    pub fn set_constellation(&mut self, v: Eo_Constellation) {
        self.constellation = v;
    }

    // .epl.protobuf.FloatField sun_azimuth = 5;


    pub fn get_sun_azimuth(&self) -> &super::query::FloatField {
        self.sun_azimuth.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_sun_azimuth(&mut self) {
        self.sun_azimuth.clear();
    }

    pub fn has_sun_azimuth(&self) -> bool {
        self.sun_azimuth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sun_azimuth(&mut self, v: super::query::FloatField) {
        self.sun_azimuth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sun_azimuth(&mut self) -> &mut super::query::FloatField {
        if self.sun_azimuth.is_none() {
            self.sun_azimuth.set_default();
        }
        self.sun_azimuth.as_mut().unwrap()
    }

    // Take field
    pub fn take_sun_azimuth(&mut self) -> super::query::FloatField {
        self.sun_azimuth.take().unwrap_or_else(|| super::query::FloatField::new())
    }

    // .epl.protobuf.FloatField sun_elevation = 6;


    pub fn get_sun_elevation(&self) -> &super::query::FloatField {
        self.sun_elevation.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_sun_elevation(&mut self) {
        self.sun_elevation.clear();
    }

    pub fn has_sun_elevation(&self) -> bool {
        self.sun_elevation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sun_elevation(&mut self, v: super::query::FloatField) {
        self.sun_elevation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sun_elevation(&mut self) -> &mut super::query::FloatField {
        if self.sun_elevation.is_none() {
            self.sun_elevation.set_default();
        }
        self.sun_elevation.as_mut().unwrap()
    }

    // Take field
    pub fn take_sun_elevation(&mut self) -> super::query::FloatField {
        self.sun_elevation.take().unwrap_or_else(|| super::query::FloatField::new())
    }

    // .epl.protobuf.FloatField gsd = 7;


    pub fn get_gsd(&self) -> &super::query::FloatField {
        self.gsd.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_gsd(&mut self) {
        self.gsd.clear();
    }

    pub fn has_gsd(&self) -> bool {
        self.gsd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gsd(&mut self, v: super::query::FloatField) {
        self.gsd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gsd(&mut self) -> &mut super::query::FloatField {
        if self.gsd.is_none() {
            self.gsd.set_default();
        }
        self.gsd.as_mut().unwrap()
    }

    // Take field
    pub fn take_gsd(&mut self) -> super::query::FloatField {
        self.gsd.take().unwrap_or_else(|| super::query::FloatField::new())
    }

    // .epl.protobuf.FloatField off_nadir = 8;


    pub fn get_off_nadir(&self) -> &super::query::FloatField {
        self.off_nadir.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_off_nadir(&mut self) {
        self.off_nadir.clear();
    }

    pub fn has_off_nadir(&self) -> bool {
        self.off_nadir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_off_nadir(&mut self, v: super::query::FloatField) {
        self.off_nadir = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_off_nadir(&mut self) -> &mut super::query::FloatField {
        if self.off_nadir.is_none() {
            self.off_nadir.set_default();
        }
        self.off_nadir.as_mut().unwrap()
    }

    // Take field
    pub fn take_off_nadir(&mut self) -> super::query::FloatField {
        self.off_nadir.take().unwrap_or_else(|| super::query::FloatField::new())
    }

    // .epl.protobuf.FloatField azimuth = 9;


    pub fn get_azimuth(&self) -> &super::query::FloatField {
        self.azimuth.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_azimuth(&mut self) {
        self.azimuth.clear();
    }

    pub fn has_azimuth(&self) -> bool {
        self.azimuth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azimuth(&mut self, v: super::query::FloatField) {
        self.azimuth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azimuth(&mut self) -> &mut super::query::FloatField {
        if self.azimuth.is_none() {
            self.azimuth.set_default();
        }
        self.azimuth.as_mut().unwrap()
    }

    // Take field
    pub fn take_azimuth(&mut self) -> super::query::FloatField {
        self.azimuth.take().unwrap_or_else(|| super::query::FloatField::new())
    }

    // .epl.protobuf.FloatField cloud_cover = 10;


    pub fn get_cloud_cover(&self) -> &super::query::FloatField {
        self.cloud_cover.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_cloud_cover(&mut self) {
        self.cloud_cover.clear();
    }

    pub fn has_cloud_cover(&self) -> bool {
        self.cloud_cover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_cover(&mut self, v: super::query::FloatField) {
        self.cloud_cover = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud_cover(&mut self) -> &mut super::query::FloatField {
        if self.cloud_cover.is_none() {
            self.cloud_cover.set_default();
        }
        self.cloud_cover.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud_cover(&mut self) -> super::query::FloatField {
        self.cloud_cover.take().unwrap_or_else(|| super::query::FloatField::new())
    }

    // .epl.protobuf.Eo.Band bands = 11;


    pub fn get_bands(&self) -> Eo_Band {
        self.bands
    }
    pub fn clear_bands(&mut self) {
        self.bands = Eo_Band::UNKNOWN_BAND;
    }

    // Param is passed by value, moved
    pub fn set_bands(&mut self, v: Eo_Band) {
        self.bands = v;
    }
}

impl ::protobuf::Message for EoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sun_azimuth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sun_elevation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gsd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.off_nadir {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azimuth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloud_cover {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.epsg = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.platform, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.instrument, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.constellation, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sun_azimuth)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sun_elevation)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gsd)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.off_nadir)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azimuth)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud_cover)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.bands, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epsg != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epsg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.platform != Eo_Platform::UNKNOWN_PLATFORM {
            my_size += ::protobuf::rt::enum_size(2, self.platform);
        }
        if self.instrument != Eo_Instrument::UNKNOWN_INSTRUMENT {
            my_size += ::protobuf::rt::enum_size(3, self.instrument);
        }
        if self.constellation != Eo_Constellation::UNKNOWN_CONSTELLATION {
            my_size += ::protobuf::rt::enum_size(4, self.constellation);
        }
        if let Some(ref v) = self.sun_azimuth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sun_elevation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gsd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.off_nadir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azimuth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloud_cover.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bands != Eo_Band::UNKNOWN_BAND {
            my_size += ::protobuf::rt::enum_size(11, self.bands);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epsg != 0 {
            os.write_int32(1, self.epsg)?;
        }
        if self.platform != Eo_Platform::UNKNOWN_PLATFORM {
            os.write_enum(2, self.platform.value())?;
        }
        if self.instrument != Eo_Instrument::UNKNOWN_INSTRUMENT {
            os.write_enum(3, self.instrument.value())?;
        }
        if self.constellation != Eo_Constellation::UNKNOWN_CONSTELLATION {
            os.write_enum(4, self.constellation.value())?;
        }
        if let Some(ref v) = self.sun_azimuth.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sun_elevation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gsd.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.off_nadir.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azimuth.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloud_cover.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bands != Eo_Band::UNKNOWN_BAND {
            os.write_enum(11, self.bands.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EoRequest {
        EoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "epsg",
                    |m: &EoRequest| { &m.epsg },
                    |m: &mut EoRequest| { &mut m.epsg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Platform>>(
                    "platform",
                    |m: &EoRequest| { &m.platform },
                    |m: &mut EoRequest| { &mut m.platform },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Instrument>>(
                    "instrument",
                    |m: &EoRequest| { &m.instrument },
                    |m: &mut EoRequest| { &mut m.instrument },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Constellation>>(
                    "constellation",
                    |m: &EoRequest| { &m.constellation },
                    |m: &mut EoRequest| { &mut m.constellation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "sun_azimuth",
                    |m: &EoRequest| { &m.sun_azimuth },
                    |m: &mut EoRequest| { &mut m.sun_azimuth },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "sun_elevation",
                    |m: &EoRequest| { &m.sun_elevation },
                    |m: &mut EoRequest| { &mut m.sun_elevation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "gsd",
                    |m: &EoRequest| { &m.gsd },
                    |m: &mut EoRequest| { &mut m.gsd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "off_nadir",
                    |m: &EoRequest| { &m.off_nadir },
                    |m: &mut EoRequest| { &mut m.off_nadir },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "azimuth",
                    |m: &EoRequest| { &m.azimuth },
                    |m: &mut EoRequest| { &mut m.azimuth },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "cloud_cover",
                    |m: &EoRequest| { &m.cloud_cover },
                    |m: &mut EoRequest| { &mut m.cloud_cover },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Eo_Band>>(
                    "bands",
                    |m: &EoRequest| { &m.bands },
                    |m: &mut EoRequest| { &mut m.bands },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EoRequest>(
                    "EoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EoRequest {
        static mut instance: ::protobuf::lazy::Lazy<EoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EoRequest,
        };
        unsafe {
            instance.get(EoRequest::new)
        }
    }
}

impl ::protobuf::Clear for EoRequest {
    fn clear(&mut self) {
        self.epsg = 0;
        self.platform = Eo_Platform::UNKNOWN_PLATFORM;
        self.instrument = Eo_Instrument::UNKNOWN_INSTRUMENT;
        self.constellation = Eo_Constellation::UNKNOWN_CONSTELLATION;
        self.sun_azimuth.clear();
        self.sun_elevation.clear();
        self.gsd.clear();
        self.off_nadir.clear();
        self.azimuth.clear();
        self.cloud_cover.clear();
        self.bands = Eo_Band::UNKNOWN_BAND;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Landsat {
    // message fields
    pub scene_id: ::std::string::String,
    pub product_id: ::std::string::String,
    pub processing_level: Landsat_ProcessingLevel,
    pub wrs_path: i32,
    pub wrs_row: i32,
    pub cloud_cover_land: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Landsat {
    fn default() -> &'a Landsat {
        <Landsat as ::protobuf::Message>::default_instance()
    }
}

impl Landsat {
    pub fn new() -> Landsat {
        ::std::default::Default::default()
    }

    // string scene_id = 1;


    pub fn get_scene_id(&self) -> &str {
        &self.scene_id
    }
    pub fn clear_scene_id(&mut self) {
        self.scene_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_scene_id(&mut self, v: ::std::string::String) {
        self.scene_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scene_id(&mut self) -> &mut ::std::string::String {
        &mut self.scene_id
    }

    // Take field
    pub fn take_scene_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scene_id, ::std::string::String::new())
    }

    // string product_id = 2;


    pub fn get_product_id(&self) -> &str {
        &self.product_id
    }
    pub fn clear_product_id(&mut self) {
        self.product_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_id(&mut self, v: ::std::string::String) {
        self.product_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_id(&mut self) -> &mut ::std::string::String {
        &mut self.product_id
    }

    // Take field
    pub fn take_product_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_id, ::std::string::String::new())
    }

    // .epl.protobuf.Landsat.ProcessingLevel processing_level = 3;


    pub fn get_processing_level(&self) -> Landsat_ProcessingLevel {
        self.processing_level
    }
    pub fn clear_processing_level(&mut self) {
        self.processing_level = Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL;
    }

    // Param is passed by value, moved
    pub fn set_processing_level(&mut self, v: Landsat_ProcessingLevel) {
        self.processing_level = v;
    }

    // int32 wrs_path = 4;


    pub fn get_wrs_path(&self) -> i32 {
        self.wrs_path
    }
    pub fn clear_wrs_path(&mut self) {
        self.wrs_path = 0;
    }

    // Param is passed by value, moved
    pub fn set_wrs_path(&mut self, v: i32) {
        self.wrs_path = v;
    }

    // int32 wrs_row = 5;


    pub fn get_wrs_row(&self) -> i32 {
        self.wrs_row
    }
    pub fn clear_wrs_row(&mut self) {
        self.wrs_row = 0;
    }

    // Param is passed by value, moved
    pub fn set_wrs_row(&mut self, v: i32) {
        self.wrs_row = v;
    }

    // .google.protobuf.FloatValue cloud_cover_land = 6;


    pub fn get_cloud_cover_land(&self) -> &::protobuf::well_known_types::FloatValue {
        self.cloud_cover_land.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }
    pub fn clear_cloud_cover_land(&mut self) {
        self.cloud_cover_land.clear();
    }

    pub fn has_cloud_cover_land(&self) -> bool {
        self.cloud_cover_land.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_cover_land(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.cloud_cover_land = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud_cover_land(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.cloud_cover_land.is_none() {
            self.cloud_cover_land.set_default();
        }
        self.cloud_cover_land.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud_cover_land(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.cloud_cover_land.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for Landsat {
    fn is_initialized(&self) -> bool {
        for v in &self.cloud_cover_land {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scene_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.processing_level, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wrs_path = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wrs_row = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud_cover_land)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scene_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scene_id);
        }
        if !self.product_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.product_id);
        }
        if self.processing_level != Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL {
            my_size += ::protobuf::rt::enum_size(3, self.processing_level);
        }
        if self.wrs_path != 0 {
            my_size += ::protobuf::rt::value_size(4, self.wrs_path, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.wrs_row != 0 {
            my_size += ::protobuf::rt::value_size(5, self.wrs_row, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cloud_cover_land.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scene_id.is_empty() {
            os.write_string(1, &self.scene_id)?;
        }
        if !self.product_id.is_empty() {
            os.write_string(2, &self.product_id)?;
        }
        if self.processing_level != Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL {
            os.write_enum(3, self.processing_level.value())?;
        }
        if self.wrs_path != 0 {
            os.write_int32(4, self.wrs_path)?;
        }
        if self.wrs_row != 0 {
            os.write_int32(5, self.wrs_row)?;
        }
        if let Some(ref v) = self.cloud_cover_land.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Landsat {
        Landsat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scene_id",
                    |m: &Landsat| { &m.scene_id },
                    |m: &mut Landsat| { &mut m.scene_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "product_id",
                    |m: &Landsat| { &m.product_id },
                    |m: &mut Landsat| { &mut m.product_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Landsat_ProcessingLevel>>(
                    "processing_level",
                    |m: &Landsat| { &m.processing_level },
                    |m: &mut Landsat| { &mut m.processing_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "wrs_path",
                    |m: &Landsat| { &m.wrs_path },
                    |m: &mut Landsat| { &mut m.wrs_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "wrs_row",
                    |m: &Landsat| { &m.wrs_row },
                    |m: &mut Landsat| { &mut m.wrs_row },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "cloud_cover_land",
                    |m: &Landsat| { &m.cloud_cover_land },
                    |m: &mut Landsat| { &mut m.cloud_cover_land },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Landsat>(
                    "Landsat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Landsat {
        static mut instance: ::protobuf::lazy::Lazy<Landsat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Landsat,
        };
        unsafe {
            instance.get(Landsat::new)
        }
    }
}

impl ::protobuf::Clear for Landsat {
    fn clear(&mut self) {
        self.scene_id.clear();
        self.product_id.clear();
        self.processing_level = Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL;
        self.wrs_path = 0;
        self.wrs_row = 0;
        self.cloud_cover_land.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Landsat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Landsat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Landsat_ProcessingLevel {
    UNKNOWN_PROCESSING_LEVEL = 0,
    L1G = 1,
    L1TP = 2,
    L1T = 3,
    L1GT = 4,
    L1GS = 5,
}

impl ::protobuf::ProtobufEnum for Landsat_ProcessingLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Landsat_ProcessingLevel> {
        match value {
            0 => ::std::option::Option::Some(Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL),
            1 => ::std::option::Option::Some(Landsat_ProcessingLevel::L1G),
            2 => ::std::option::Option::Some(Landsat_ProcessingLevel::L1TP),
            3 => ::std::option::Option::Some(Landsat_ProcessingLevel::L1T),
            4 => ::std::option::Option::Some(Landsat_ProcessingLevel::L1GT),
            5 => ::std::option::Option::Some(Landsat_ProcessingLevel::L1GS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Landsat_ProcessingLevel] = &[
            Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL,
            Landsat_ProcessingLevel::L1G,
            Landsat_ProcessingLevel::L1TP,
            Landsat_ProcessingLevel::L1T,
            Landsat_ProcessingLevel::L1GT,
            Landsat_ProcessingLevel::L1GS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Landsat_ProcessingLevel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Landsat_ProcessingLevel {
}

impl ::std::default::Default for Landsat_ProcessingLevel {
    fn default() -> Self {
        Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL
    }
}

impl ::protobuf::reflect::ProtobufValue for Landsat_ProcessingLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LandsatRequest {
    // message fields
    pub scene_id: ::std::string::String,
    pub product_id: ::std::string::String,
    pub processing_level: Landsat_ProcessingLevel,
    pub wrs_path: i32,
    pub wrs_row: i32,
    pub cloud_cover_land: ::protobuf::SingularPtrField<super::query::FloatField>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LandsatRequest {
    fn default() -> &'a LandsatRequest {
        <LandsatRequest as ::protobuf::Message>::default_instance()
    }
}

impl LandsatRequest {
    pub fn new() -> LandsatRequest {
        ::std::default::Default::default()
    }

    // string scene_id = 1;


    pub fn get_scene_id(&self) -> &str {
        &self.scene_id
    }
    pub fn clear_scene_id(&mut self) {
        self.scene_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_scene_id(&mut self, v: ::std::string::String) {
        self.scene_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scene_id(&mut self) -> &mut ::std::string::String {
        &mut self.scene_id
    }

    // Take field
    pub fn take_scene_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scene_id, ::std::string::String::new())
    }

    // string product_id = 2;


    pub fn get_product_id(&self) -> &str {
        &self.product_id
    }
    pub fn clear_product_id(&mut self) {
        self.product_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_id(&mut self, v: ::std::string::String) {
        self.product_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_id(&mut self) -> &mut ::std::string::String {
        &mut self.product_id
    }

    // Take field
    pub fn take_product_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_id, ::std::string::String::new())
    }

    // .epl.protobuf.Landsat.ProcessingLevel processing_level = 3;


    pub fn get_processing_level(&self) -> Landsat_ProcessingLevel {
        self.processing_level
    }
    pub fn clear_processing_level(&mut self) {
        self.processing_level = Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL;
    }

    // Param is passed by value, moved
    pub fn set_processing_level(&mut self, v: Landsat_ProcessingLevel) {
        self.processing_level = v;
    }

    // int32 wrs_path = 4;


    pub fn get_wrs_path(&self) -> i32 {
        self.wrs_path
    }
    pub fn clear_wrs_path(&mut self) {
        self.wrs_path = 0;
    }

    // Param is passed by value, moved
    pub fn set_wrs_path(&mut self, v: i32) {
        self.wrs_path = v;
    }

    // int32 wrs_row = 5;


    pub fn get_wrs_row(&self) -> i32 {
        self.wrs_row
    }
    pub fn clear_wrs_row(&mut self) {
        self.wrs_row = 0;
    }

    // Param is passed by value, moved
    pub fn set_wrs_row(&mut self, v: i32) {
        self.wrs_row = v;
    }

    // .epl.protobuf.FloatField cloud_cover_land = 6;


    pub fn get_cloud_cover_land(&self) -> &super::query::FloatField {
        self.cloud_cover_land.as_ref().unwrap_or_else(|| super::query::FloatField::default_instance())
    }
    pub fn clear_cloud_cover_land(&mut self) {
        self.cloud_cover_land.clear();
    }

    pub fn has_cloud_cover_land(&self) -> bool {
        self.cloud_cover_land.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_cover_land(&mut self, v: super::query::FloatField) {
        self.cloud_cover_land = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud_cover_land(&mut self) -> &mut super::query::FloatField {
        if self.cloud_cover_land.is_none() {
            self.cloud_cover_land.set_default();
        }
        self.cloud_cover_land.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud_cover_land(&mut self) -> super::query::FloatField {
        self.cloud_cover_land.take().unwrap_or_else(|| super::query::FloatField::new())
    }
}

impl ::protobuf::Message for LandsatRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.cloud_cover_land {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scene_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.processing_level, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wrs_path = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wrs_row = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud_cover_land)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scene_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scene_id);
        }
        if !self.product_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.product_id);
        }
        if self.processing_level != Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL {
            my_size += ::protobuf::rt::enum_size(3, self.processing_level);
        }
        if self.wrs_path != 0 {
            my_size += ::protobuf::rt::value_size(4, self.wrs_path, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.wrs_row != 0 {
            my_size += ::protobuf::rt::value_size(5, self.wrs_row, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cloud_cover_land.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scene_id.is_empty() {
            os.write_string(1, &self.scene_id)?;
        }
        if !self.product_id.is_empty() {
            os.write_string(2, &self.product_id)?;
        }
        if self.processing_level != Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL {
            os.write_enum(3, self.processing_level.value())?;
        }
        if self.wrs_path != 0 {
            os.write_int32(4, self.wrs_path)?;
        }
        if self.wrs_row != 0 {
            os.write_int32(5, self.wrs_row)?;
        }
        if let Some(ref v) = self.cloud_cover_land.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LandsatRequest {
        LandsatRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scene_id",
                    |m: &LandsatRequest| { &m.scene_id },
                    |m: &mut LandsatRequest| { &mut m.scene_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "product_id",
                    |m: &LandsatRequest| { &m.product_id },
                    |m: &mut LandsatRequest| { &mut m.product_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Landsat_ProcessingLevel>>(
                    "processing_level",
                    |m: &LandsatRequest| { &m.processing_level },
                    |m: &mut LandsatRequest| { &mut m.processing_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "wrs_path",
                    |m: &LandsatRequest| { &m.wrs_path },
                    |m: &mut LandsatRequest| { &mut m.wrs_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "wrs_row",
                    |m: &LandsatRequest| { &m.wrs_row },
                    |m: &mut LandsatRequest| { &mut m.wrs_row },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::query::FloatField>>(
                    "cloud_cover_land",
                    |m: &LandsatRequest| { &m.cloud_cover_land },
                    |m: &mut LandsatRequest| { &mut m.cloud_cover_land },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LandsatRequest>(
                    "LandsatRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LandsatRequest {
        static mut instance: ::protobuf::lazy::Lazy<LandsatRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LandsatRequest,
        };
        unsafe {
            instance.get(LandsatRequest::new)
        }
    }
}

impl ::protobuf::Clear for LandsatRequest {
    fn clear(&mut self) {
        self.scene_id.clear();
        self.product_id.clear();
        self.processing_level = Landsat_ProcessingLevel::UNKNOWN_PROCESSING_LEVEL;
        self.wrs_path = 0;
        self.wrs_row = 0;
        self.cloud_cover_land.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LandsatRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LandsatRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum AssetType {
    UNKNOWN_ASSET = 0,
    JPEG = 1,
    GEOTIFF = 2,
    LERC = 3,
    MRF = 4,
    MRF_IDX = 5,
    MRF_XML = 6,
    CO_GEOTIFF = 7,
    RAW = 8,
    THUMBNAIL = 9,
    TIFF = 10,
    JPEG_2000 = 11,
    XML = 12,
    TXT = 13,
    PNG = 14,
    OVERVIEW = 15,
    JSON = 16,
    HTML = 17,
    WEBP = 18,
}

impl ::protobuf::ProtobufEnum for AssetType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssetType> {
        match value {
            0 => ::std::option::Option::Some(AssetType::UNKNOWN_ASSET),
            1 => ::std::option::Option::Some(AssetType::JPEG),
            2 => ::std::option::Option::Some(AssetType::GEOTIFF),
            3 => ::std::option::Option::Some(AssetType::LERC),
            4 => ::std::option::Option::Some(AssetType::MRF),
            5 => ::std::option::Option::Some(AssetType::MRF_IDX),
            6 => ::std::option::Option::Some(AssetType::MRF_XML),
            7 => ::std::option::Option::Some(AssetType::CO_GEOTIFF),
            8 => ::std::option::Option::Some(AssetType::RAW),
            9 => ::std::option::Option::Some(AssetType::THUMBNAIL),
            10 => ::std::option::Option::Some(AssetType::TIFF),
            11 => ::std::option::Option::Some(AssetType::JPEG_2000),
            12 => ::std::option::Option::Some(AssetType::XML),
            13 => ::std::option::Option::Some(AssetType::TXT),
            14 => ::std::option::Option::Some(AssetType::PNG),
            15 => ::std::option::Option::Some(AssetType::OVERVIEW),
            16 => ::std::option::Option::Some(AssetType::JSON),
            17 => ::std::option::Option::Some(AssetType::HTML),
            18 => ::std::option::Option::Some(AssetType::WEBP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssetType] = &[
            AssetType::UNKNOWN_ASSET,
            AssetType::JPEG,
            AssetType::GEOTIFF,
            AssetType::LERC,
            AssetType::MRF,
            AssetType::MRF_IDX,
            AssetType::MRF_XML,
            AssetType::CO_GEOTIFF,
            AssetType::RAW,
            AssetType::THUMBNAIL,
            AssetType::TIFF,
            AssetType::JPEG_2000,
            AssetType::XML,
            AssetType::TXT,
            AssetType::PNG,
            AssetType::OVERVIEW,
            AssetType::JSON,
            AssetType::HTML,
            AssetType::WEBP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AssetType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AssetType {
}

impl ::std::default::Default for AssetType {
    fn default() -> Self {
        AssetType::UNKNOWN_ASSET
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum CloudPlatform {
    UNKNOWN_CLOUD_PLATFORM = 0,
    AWS = 1,
    GCP = 2,
    AZURE = 3,
}

impl ::protobuf::ProtobufEnum for CloudPlatform {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CloudPlatform> {
        match value {
            0 => ::std::option::Option::Some(CloudPlatform::UNKNOWN_CLOUD_PLATFORM),
            1 => ::std::option::Option::Some(CloudPlatform::AWS),
            2 => ::std::option::Option::Some(CloudPlatform::GCP),
            3 => ::std::option::Option::Some(CloudPlatform::AZURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CloudPlatform] = &[
            CloudPlatform::UNKNOWN_CLOUD_PLATFORM,
            CloudPlatform::AWS,
            CloudPlatform::GCP,
            CloudPlatform::AZURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CloudPlatform", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CloudPlatform {
}

impl ::std::default::Default for CloudPlatform {
    fn default() -> Self {
        CloudPlatform::UNKNOWN_CLOUD_PLATFORM
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudPlatform {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17epl/protobuf/stac.proto\x12\x0cepl.protobuf\x1a\x1fgoogle/protobuf\
    /timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/pro\
    tobuf/wrappers.proto\x1a\x19google/protobuf/any.proto\x1a\x1bepl/protobu\
    f/geometry.proto\x1a\x18epl/protobuf/query.proto\"\x95\x06\n\x08StacItem\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x126\n\x08geometry\x18\x03\
    \x20\x01(\x0b2\x1a.epl.protobuf.GeometryDataR\x08geometry\x12.\n\x04bbox\
    \x18\x04\x20\x01(\x0b2\x1a.epl.protobuf.EnvelopeDataR\x04bbox\x124\n\npr\
    operties\x18\x05\x20\x01(\x0b2\x14.google.protobuf.AnyR\nproperties\x12:\
    \n\x06assets\x18\x07\x20\x03(\x0b2\".epl.protobuf.StacItem.AssetsEntryR\
    \x06assets\x126\n\x08datetime\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.\
    TimestampR\x08datetime\x12\x14\n\x05title\x18\t\x20\x01(\tR\x05title\x12\
    \x1e\n\ncollection\x18\n\x20\x01(\tR\ncollection\x126\n\x08observed\x18\
    \x0b\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x08observed\x125\n\x08\
    duration\x18\x12\x20\x01(\x0b2\x19.google.protobuf.DurationR\x08duration\
    \x128\n\tprocessed\x18\x0c\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tprocessed\x124\n\x07updated\x18\r\x20\x01(\x0b2\x1a.google.protobuf.Ti\
    mestampR\x07updated\x12\x20\n\x02eo\x18\x0e\x20\x01(\x0b2\x10.epl.protob\
    uf.EoR\x02eo\x12#\n\x03sar\x18\x0f\x20\x01(\x0b2\x11.epl.protobuf.SarR\
    \x03sar\x12/\n\x07landsat\x18\x11\x20\x01(\x0b2\x15.epl.protobuf.Landsat\
    R\x07landsat\x1aN\n\x0bAssetsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12)\n\x05value\x18\x02\x20\x01(\x0b2\x13.epl.protobuf.AssetR\
    \x05value:\x028\x01J\x04\x08\x06\x10\x07J\x04\x08\x10\x10\x11\"\xd6\x05\
    \n\x0bStacRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x126\n\x08ge\
    ometry\x18\x02\x20\x01(\x0b2\x1a.epl.protobuf.GeometryDataR\x08geometry\
    \x12.\n\x04bbox\x18\x03\x20\x01(\x0b2\x1a.epl.protobuf.EnvelopeDataR\x04\
    bbox\x12H\n\x10geometry_request\x18\x04\x20\x01(\x0b2\x1d.epl.protobuf.G\
    eometryRequestR\x0fgeometryRequest\x124\n\nproperties\x18\x05\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\nproperties\x128\n\x08datetime\x18\x06\
    \x20\x01(\x0b2\x1c.epl.protobuf.TimestampFieldR\x08datetime\x128\n\x08ob\
    served\x18\x07\x20\x01(\x0b2\x1c.epl.protobuf.TimestampFieldR\x08observe\
    d\x12:\n\tprocessed\x18\x08\x20\x01(\x0b2\x1c.epl.protobuf.TimestampFiel\
    dR\tprocessed\x126\n\x07updated\x18\t\x20\x01(\x0b2\x1c.epl.protobuf.Tim\
    estampFieldR\x07updated\x12'\n\x02eo\x18\n\x20\x01(\x0b2\x17.epl.protobu\
    f.EoRequestR\x02eo\x12\x14\n\x05limit\x18\x0b\x20\x01(\rR\x05limit\x12\
    \x16\n\x06offset\x18\x0c\x20\x01(\x04R\x06offset\x126\n\x07landsat\x18\r\
    \x20\x01(\x0b2\x1c.epl.protobuf.LandsatRequestR\x07landsat\x12\x1e\n\nco\
    llection\x18\x0e\x20\x01(\tR\ncollection\x128\n\nid_complex\x18\x0f\x20\
    \x01(\x0b2\x19.epl.protobuf.StringFieldR\tidComplex\"\x89\x03\n\x05Asset\
    \x12\x12\n\x04href\x18\x01\x20\x01(\tR\x04href\x12\x12\n\x04type\x18\x02\
    \x20\x01(\tR\x04type\x120\n\x08eo_bands\x18\x03\x20\x01(\x0e2\x15.epl.pr\
    otobuf.Eo.BandR\x07eoBands\x126\n\nasset_type\x18\x04\x20\x01(\x0e2\x17.\
    epl.protobuf.AssetTypeR\tassetType\x12B\n\x0ecloud_platform\x18\x05\x20\
    \x01(\x0e2\x1b.epl.protobuf.CloudPlatformR\rcloudPlatform\x12%\n\x0ebuck\
    et_manager\x18\x06\x20\x01(\tR\rbucketManager\x12#\n\rbucket_region\x18\
    \x07\x20\x01(\tR\x0cbucketRegion\x12\x16\n\x06bucket\x18\x08\x20\x01(\tR\
    \x06bucket\x12\x1f\n\x0bobject_path\x18\t\x20\x01(\tR\nobjectPath\x12%\n\
    \x0erequester_pays\x18\n\x20\x01(\x08R\rrequesterPays\"o\n\rDatetimeRang\
    e\x120\n\x05start\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x05start\x12,\n\x03end\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\x03end\"x\n\x0eStacDbResponse\x12\x16\n\x06status\x18\x01\x20\x01(\
    \tR\x06status\x12\x1f\n\x0bstatus_code\x18\x02\x20\x01(\x05R\nstatusCode\
    \x12\x17\n\x07data_id\x18\x03\x20\x01(\tR\x06dataId\x12\x14\n\x05count\
    \x18\x04\x20\x01(\x04R\x05count\"\xa3\x01\n\x03Sar\x126\n\x08platform\
    \x18\x01\x20\x01(\x0e2\x1a.epl.protobuf.Sar.PlatformR\x08platform\">\n\
    \x08Platform\x12\x14\n\x10UNKNOWN_PLATFORM\x10\0\x12\x0b\n\x07ENVISAT\
    \x10\x01\x12\x0f\n\x0bSENTINEL_1A\x10\x02\"$\n\nInstrument\x12\x16\n\x12\
    UNKNOWN_INSTRUMENT\x10\0\"\xc9\t\n\x02Eo\x12\x12\n\x04epsg\x18\x01\x20\
    \x01(\rR\x04epsg\x125\n\x08platform\x18\x02\x20\x01(\x0e2\x19.epl.protob\
    uf.Eo.PlatformR\x08platform\x12;\n\ninstrument\x18\x03\x20\x01(\x0e2\x1b\
    .epl.protobuf.Eo.InstrumentR\ninstrument\x12D\n\rconstellation\x18\x04\
    \x20\x01(\x0e2\x1e.epl.protobuf.Eo.ConstellationR\rconstellation\x12<\n\
    \x0bsun_azimuth\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\ns\
    unAzimuth\x12@\n\rsun_elevation\x18\x06\x20\x01(\x0b2\x1b.google.protobu\
    f.FloatValueR\x0csunElevation\x12-\n\x03gsd\x18\x07\x20\x01(\x0b2\x1b.go\
    ogle.protobuf.FloatValueR\x03gsd\x128\n\toff_nadir\x18\x08\x20\x01(\x0b2\
    \x1b.google.protobuf.FloatValueR\x08offNadir\x125\n\x07azimuth\x18\t\x20\
    \x01(\x0b2\x1b.google.protobuf.FloatValueR\x07azimuth\x12<\n\x0bcloud_co\
    ver\x18\n\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\ncloudCover\x12+\
    \n\x05bands\x18\x0b\x20\x01(\x0e2\x15.epl.protobuf.Eo.BandR\x05bands\x12\
    2\n\x02sr\x18\x0c\x20\x01(\x0b2\".epl.protobuf.SpatialReferenceDataR\x02\
    sr\"\xb9\x01\n\x08Platform\x12\x14\n\x10UNKNOWN_PLATFORM\x10\0\x12\r\n\t\
    LANDSAT_1\x10\x02\x12\r\n\tLANDSAT_2\x10\x04\x12\r\n\tLANDSAT_3\x10\x08\
    \x12\x0f\n\x0bLANDSAT_123\x10\x0e\x12\r\n\tLANDSAT_4\x10\x10\x12\r\n\tLA\
    NDSAT_5\x10\x20\x12\x0e\n\nLANDSAT_45\x100\x12\r\n\tLANDSAT_7\x10@\x12\
    \x0e\n\tLANDSAT_8\x10\x80\x01\x12\x0c\n\x07SWIFT_2\x10\x80\x02\"j\n\nIns\
    trument\x12\x16\n\x12UNKNOWN_INSTRUMENT\x10\0\x12\x07\n\x03OLI\x10\x02\
    \x12\x08\n\x04TIRS\x10\x04\x12\x0c\n\x08OLI_TIRS\x10\x06\x12\t\n\x05POM_\
    1\x10\x08\x12\x06\n\x02TM\x10\x10\x12\x07\n\x03ETM\x10\x20\x12\x07\n\x03\
    MSS\x10@\"V\n\rConstellation\x12\x19\n\x15UNKNOWN_CONSTELLATION\x10\0\
    \x12\x0b\n\x07LANDSAT\x10\x02\x12\x08\n\x04NAIP\x10\x04\x12\x08\n\x04PNO\
    A\x10\x08\x12\t\n\x05SWIFT\x10\x10\"\xb5\x01\n\x04Band\x12\x10\n\x0cUNKN\
    OWN_BAND\x10\0\x12\x0b\n\x07COASTAL\x10\x02\x12\x08\n\x04BLUE\x10\x04\
    \x12\t\n\x05GREEN\x10\x08\x12\x07\n\x03RED\x10\x10\x12\x07\n\x03RGB\x10\
    \x1c\x12\x07\n\x03NIR\x10\x20\x12\t\n\x05NIR_2\x10!\x12\t\n\x05RGBIR\x10\
    <\x12\n\n\x06SWIR_1\x10@\x12\x0b\n\x06SWIR_2\x10\x80\x01\x12\x08\n\x03PA\
    N\x10\x80\x02\x12\x0b\n\x06CIRRUS\x10\x80\x04\x12\x0b\n\x06LWIR_1\x10\
    \x80\x08\x12\x0b\n\x06LWIR_2\x10\x80\x10\"\xd2\x04\n\tEoRequest\x12\x12\
    \n\x04epsg\x18\x01\x20\x01(\x05R\x04epsg\x125\n\x08platform\x18\x02\x20\
    \x01(\x0e2\x19.epl.protobuf.Eo.PlatformR\x08platform\x12;\n\ninstrument\
    \x18\x03\x20\x01(\x0e2\x1b.epl.protobuf.Eo.InstrumentR\ninstrument\x12D\
    \n\rconstellation\x18\x04\x20\x01(\x0e2\x1e.epl.protobuf.Eo.Constellatio\
    nR\rconstellation\x129\n\x0bsun_azimuth\x18\x05\x20\x01(\x0b2\x18.epl.pr\
    otobuf.FloatFieldR\nsunAzimuth\x12=\n\rsun_elevation\x18\x06\x20\x01(\
    \x0b2\x18.epl.protobuf.FloatFieldR\x0csunElevation\x12*\n\x03gsd\x18\x07\
    \x20\x01(\x0b2\x18.epl.protobuf.FloatFieldR\x03gsd\x125\n\toff_nadir\x18\
    \x08\x20\x01(\x0b2\x18.epl.protobuf.FloatFieldR\x08offNadir\x122\n\x07az\
    imuth\x18\t\x20\x01(\x0b2\x18.epl.protobuf.FloatFieldR\x07azimuth\x129\n\
    \x0bcloud_cover\x18\n\x20\x01(\x0b2\x18.epl.protobuf.FloatFieldR\ncloudC\
    over\x12+\n\x05bands\x18\x0b\x20\x01(\x0e2\x15.epl.protobuf.Eo.BandR\x05\
    bands\"\xf1\x02\n\x07Landsat\x12\x19\n\x08scene_id\x18\x01\x20\x01(\tR\
    \x07sceneId\x12\x1d\n\nproduct_id\x18\x02\x20\x01(\tR\tproductId\x12P\n\
    \x10processing_level\x18\x03\x20\x01(\x0e2%.epl.protobuf.Landsat.Process\
    ingLevelR\x0fprocessingLevel\x12\x19\n\x08wrs_path\x18\x04\x20\x01(\x05R\
    \x07wrsPath\x12\x17\n\x07wrs_row\x18\x05\x20\x01(\x05R\x06wrsRow\x12E\n\
    \x10cloud_cover_land\x18\x06\x20\x01(\x0b2\x1b.google.protobuf.FloatValu\
    eR\x0ecloudCoverLand\"_\n\x0fProcessingLevel\x12\x1c\n\x18UNKNOWN_PROCES\
    SING_LEVEL\x10\0\x12\x07\n\x03L1G\x10\x01\x12\x08\n\x04L1TP\x10\x02\x12\
    \x07\n\x03L1T\x10\x03\x12\x08\n\x04L1GT\x10\x04\x12\x08\n\x04L1GS\x10\
    \x05\"\x94\x02\n\x0eLandsatRequest\x12\x19\n\x08scene_id\x18\x01\x20\x01\
    (\tR\x07sceneId\x12\x1d\n\nproduct_id\x18\x02\x20\x01(\tR\tproductId\x12\
    P\n\x10processing_level\x18\x03\x20\x01(\x0e2%.epl.protobuf.Landsat.Proc\
    essingLevelR\x0fprocessingLevel\x12\x19\n\x08wrs_path\x18\x04\x20\x01(\
    \x05R\x07wrsPath\x12\x17\n\x07wrs_row\x18\x05\x20\x01(\x05R\x06wrsRow\
    \x12B\n\x10cloud_cover_land\x18\x06\x20\x01(\x0b2\x18.epl.protobuf.Float\
    FieldR\x0ecloudCoverLand*\xea\x01\n\tAssetType\x12\x11\n\rUNKNOWN_ASSET\
    \x10\0\x12\x08\n\x04JPEG\x10\x01\x12\x0b\n\x07GEOTIFF\x10\x02\x12\x08\n\
    \x04LERC\x10\x03\x12\x07\n\x03MRF\x10\x04\x12\x0b\n\x07MRF_IDX\x10\x05\
    \x12\x0b\n\x07MRF_XML\x10\x06\x12\x0e\n\nCO_GEOTIFF\x10\x07\x12\x07\n\
    \x03RAW\x10\x08\x12\r\n\tTHUMBNAIL\x10\t\x12\x08\n\x04TIFF\x10\n\x12\r\n\
    \tJPEG_2000\x10\x0b\x12\x07\n\x03XML\x10\x0c\x12\x07\n\x03TXT\x10\r\x12\
    \x07\n\x03PNG\x10\x0e\x12\x0c\n\x08OVERVIEW\x10\x0f\x12\x08\n\x04JSON\
    \x10\x10\x12\x08\n\x04HTML\x10\x11\x12\x08\n\x04WEBP\x10\x12*H\n\rCloudP\
    latform\x12\x1a\n\x16UNKNOWN_CLOUD_PLATFORM\x10\0\x12\x07\n\x03AWS\x10\
    \x01\x12\x07\n\x03GCP\x10\x02\x12\t\n\x05AZURE\x10\x03BS\n\x10com.epl.pr\
    otobufB\tStacProtoP\x01Z+github.com/geo-grpc/api/golang/epl/protobuf\xa2\
    \x02\x04STPBb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
